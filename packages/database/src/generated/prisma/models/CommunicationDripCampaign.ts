
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `CommunicationDripCampaign` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model CommunicationDripCampaign
 * 
 */
export type CommunicationDripCampaignModel = runtime.Types.Result.DefaultSelection<Prisma.$CommunicationDripCampaignPayload>

export type AggregateCommunicationDripCampaign = {
  _count: CommunicationDripCampaignCountAggregateOutputType | null
  _min: CommunicationDripCampaignMinAggregateOutputType | null
  _max: CommunicationDripCampaignMaxAggregateOutputType | null
}

export type CommunicationDripCampaignMinAggregateOutputType = {
  id: string | null
  churchId: string | null
  name: string | null
  description: string | null
  status: $Enums.DripCampaignStatus | null
  createdAt: Date | null
  updatedAt: Date | null
}

export type CommunicationDripCampaignMaxAggregateOutputType = {
  id: string | null
  churchId: string | null
  name: string | null
  description: string | null
  status: $Enums.DripCampaignStatus | null
  createdAt: Date | null
  updatedAt: Date | null
}

export type CommunicationDripCampaignCountAggregateOutputType = {
  id: number
  churchId: number
  name: number
  description: number
  status: number
  createdAt: number
  updatedAt: number
  _all: number
}


export type CommunicationDripCampaignMinAggregateInputType = {
  id?: true
  churchId?: true
  name?: true
  description?: true
  status?: true
  createdAt?: true
  updatedAt?: true
}

export type CommunicationDripCampaignMaxAggregateInputType = {
  id?: true
  churchId?: true
  name?: true
  description?: true
  status?: true
  createdAt?: true
  updatedAt?: true
}

export type CommunicationDripCampaignCountAggregateInputType = {
  id?: true
  churchId?: true
  name?: true
  description?: true
  status?: true
  createdAt?: true
  updatedAt?: true
  _all?: true
}

export type CommunicationDripCampaignAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which CommunicationDripCampaign to aggregate.
   */
  where?: Prisma.CommunicationDripCampaignWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of CommunicationDripCampaigns to fetch.
   */
  orderBy?: Prisma.CommunicationDripCampaignOrderByWithRelationInput | Prisma.CommunicationDripCampaignOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.CommunicationDripCampaignWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` CommunicationDripCampaigns from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` CommunicationDripCampaigns.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned CommunicationDripCampaigns
  **/
  _count?: true | CommunicationDripCampaignCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: CommunicationDripCampaignMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: CommunicationDripCampaignMaxAggregateInputType
}

export type GetCommunicationDripCampaignAggregateType<T extends CommunicationDripCampaignAggregateArgs> = {
      [P in keyof T & keyof AggregateCommunicationDripCampaign]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateCommunicationDripCampaign[P]>
    : Prisma.GetScalarType<T[P], AggregateCommunicationDripCampaign[P]>
}




export type CommunicationDripCampaignGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.CommunicationDripCampaignWhereInput
  orderBy?: Prisma.CommunicationDripCampaignOrderByWithAggregationInput | Prisma.CommunicationDripCampaignOrderByWithAggregationInput[]
  by: Prisma.CommunicationDripCampaignScalarFieldEnum[] | Prisma.CommunicationDripCampaignScalarFieldEnum
  having?: Prisma.CommunicationDripCampaignScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: CommunicationDripCampaignCountAggregateInputType | true
  _min?: CommunicationDripCampaignMinAggregateInputType
  _max?: CommunicationDripCampaignMaxAggregateInputType
}

export type CommunicationDripCampaignGroupByOutputType = {
  id: string
  churchId: string
  name: string
  description: string | null
  status: $Enums.DripCampaignStatus
  createdAt: Date
  updatedAt: Date
  _count: CommunicationDripCampaignCountAggregateOutputType | null
  _min: CommunicationDripCampaignMinAggregateOutputType | null
  _max: CommunicationDripCampaignMaxAggregateOutputType | null
}

type GetCommunicationDripCampaignGroupByPayload<T extends CommunicationDripCampaignGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<CommunicationDripCampaignGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof CommunicationDripCampaignGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], CommunicationDripCampaignGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], CommunicationDripCampaignGroupByOutputType[P]>
      }
    >
  >



export type CommunicationDripCampaignWhereInput = {
  AND?: Prisma.CommunicationDripCampaignWhereInput | Prisma.CommunicationDripCampaignWhereInput[]
  OR?: Prisma.CommunicationDripCampaignWhereInput[]
  NOT?: Prisma.CommunicationDripCampaignWhereInput | Prisma.CommunicationDripCampaignWhereInput[]
  id?: Prisma.StringFilter<"CommunicationDripCampaign"> | string
  churchId?: Prisma.StringFilter<"CommunicationDripCampaign"> | string
  name?: Prisma.StringFilter<"CommunicationDripCampaign"> | string
  description?: Prisma.StringNullableFilter<"CommunicationDripCampaign"> | string | null
  status?: Prisma.EnumDripCampaignStatusFilter<"CommunicationDripCampaign"> | $Enums.DripCampaignStatus
  createdAt?: Prisma.DateTimeFilter<"CommunicationDripCampaign"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"CommunicationDripCampaign"> | Date | string
  church?: Prisma.XOR<Prisma.ChurchScalarRelationFilter, Prisma.ChurchWhereInput>
  steps?: Prisma.CommunicationDripStepListRelationFilter
  enrollments?: Prisma.CommunicationDripEnrollmentListRelationFilter
}

export type CommunicationDripCampaignOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  churchId?: Prisma.SortOrder
  name?: Prisma.SortOrder
  description?: Prisma.SortOrderInput | Prisma.SortOrder
  status?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  church?: Prisma.ChurchOrderByWithRelationInput
  steps?: Prisma.CommunicationDripStepOrderByRelationAggregateInput
  enrollments?: Prisma.CommunicationDripEnrollmentOrderByRelationAggregateInput
}

export type CommunicationDripCampaignWhereUniqueInput = Prisma.AtLeast<{
  id?: string
  churchId_name?: Prisma.CommunicationDripCampaignChurchIdNameCompoundUniqueInput
  AND?: Prisma.CommunicationDripCampaignWhereInput | Prisma.CommunicationDripCampaignWhereInput[]
  OR?: Prisma.CommunicationDripCampaignWhereInput[]
  NOT?: Prisma.CommunicationDripCampaignWhereInput | Prisma.CommunicationDripCampaignWhereInput[]
  churchId?: Prisma.StringFilter<"CommunicationDripCampaign"> | string
  name?: Prisma.StringFilter<"CommunicationDripCampaign"> | string
  description?: Prisma.StringNullableFilter<"CommunicationDripCampaign"> | string | null
  status?: Prisma.EnumDripCampaignStatusFilter<"CommunicationDripCampaign"> | $Enums.DripCampaignStatus
  createdAt?: Prisma.DateTimeFilter<"CommunicationDripCampaign"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"CommunicationDripCampaign"> | Date | string
  church?: Prisma.XOR<Prisma.ChurchScalarRelationFilter, Prisma.ChurchWhereInput>
  steps?: Prisma.CommunicationDripStepListRelationFilter
  enrollments?: Prisma.CommunicationDripEnrollmentListRelationFilter
}, "id" | "churchId_name">

export type CommunicationDripCampaignOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  churchId?: Prisma.SortOrder
  name?: Prisma.SortOrder
  description?: Prisma.SortOrderInput | Prisma.SortOrder
  status?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  _count?: Prisma.CommunicationDripCampaignCountOrderByAggregateInput
  _max?: Prisma.CommunicationDripCampaignMaxOrderByAggregateInput
  _min?: Prisma.CommunicationDripCampaignMinOrderByAggregateInput
}

export type CommunicationDripCampaignScalarWhereWithAggregatesInput = {
  AND?: Prisma.CommunicationDripCampaignScalarWhereWithAggregatesInput | Prisma.CommunicationDripCampaignScalarWhereWithAggregatesInput[]
  OR?: Prisma.CommunicationDripCampaignScalarWhereWithAggregatesInput[]
  NOT?: Prisma.CommunicationDripCampaignScalarWhereWithAggregatesInput | Prisma.CommunicationDripCampaignScalarWhereWithAggregatesInput[]
  id?: Prisma.StringWithAggregatesFilter<"CommunicationDripCampaign"> | string
  churchId?: Prisma.StringWithAggregatesFilter<"CommunicationDripCampaign"> | string
  name?: Prisma.StringWithAggregatesFilter<"CommunicationDripCampaign"> | string
  description?: Prisma.StringNullableWithAggregatesFilter<"CommunicationDripCampaign"> | string | null
  status?: Prisma.EnumDripCampaignStatusWithAggregatesFilter<"CommunicationDripCampaign"> | $Enums.DripCampaignStatus
  createdAt?: Prisma.DateTimeWithAggregatesFilter<"CommunicationDripCampaign"> | Date | string
  updatedAt?: Prisma.DateTimeWithAggregatesFilter<"CommunicationDripCampaign"> | Date | string
}

export type CommunicationDripCampaignCreateInput = {
  id?: string
  name: string
  description?: string | null
  status?: $Enums.DripCampaignStatus
  createdAt?: Date | string
  updatedAt?: Date | string
  church: Prisma.ChurchCreateNestedOneWithoutDripCampaignsInput
  steps?: Prisma.CommunicationDripStepCreateNestedManyWithoutCampaignInput
  enrollments?: Prisma.CommunicationDripEnrollmentCreateNestedManyWithoutCampaignInput
}

export type CommunicationDripCampaignUncheckedCreateInput = {
  id?: string
  churchId: string
  name: string
  description?: string | null
  status?: $Enums.DripCampaignStatus
  createdAt?: Date | string
  updatedAt?: Date | string
  steps?: Prisma.CommunicationDripStepUncheckedCreateNestedManyWithoutCampaignInput
  enrollments?: Prisma.CommunicationDripEnrollmentUncheckedCreateNestedManyWithoutCampaignInput
}

export type CommunicationDripCampaignUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  name?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  status?: Prisma.EnumDripCampaignStatusFieldUpdateOperationsInput | $Enums.DripCampaignStatus
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  church?: Prisma.ChurchUpdateOneRequiredWithoutDripCampaignsNestedInput
  steps?: Prisma.CommunicationDripStepUpdateManyWithoutCampaignNestedInput
  enrollments?: Prisma.CommunicationDripEnrollmentUpdateManyWithoutCampaignNestedInput
}

export type CommunicationDripCampaignUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  churchId?: Prisma.StringFieldUpdateOperationsInput | string
  name?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  status?: Prisma.EnumDripCampaignStatusFieldUpdateOperationsInput | $Enums.DripCampaignStatus
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  steps?: Prisma.CommunicationDripStepUncheckedUpdateManyWithoutCampaignNestedInput
  enrollments?: Prisma.CommunicationDripEnrollmentUncheckedUpdateManyWithoutCampaignNestedInput
}

export type CommunicationDripCampaignCreateManyInput = {
  id?: string
  churchId: string
  name: string
  description?: string | null
  status?: $Enums.DripCampaignStatus
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type CommunicationDripCampaignUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  name?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  status?: Prisma.EnumDripCampaignStatusFieldUpdateOperationsInput | $Enums.DripCampaignStatus
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type CommunicationDripCampaignUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  churchId?: Prisma.StringFieldUpdateOperationsInput | string
  name?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  status?: Prisma.EnumDripCampaignStatusFieldUpdateOperationsInput | $Enums.DripCampaignStatus
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type CommunicationDripCampaignListRelationFilter = {
  every?: Prisma.CommunicationDripCampaignWhereInput
  some?: Prisma.CommunicationDripCampaignWhereInput
  none?: Prisma.CommunicationDripCampaignWhereInput
}

export type CommunicationDripCampaignOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type CommunicationDripCampaignChurchIdNameCompoundUniqueInput = {
  churchId: string
  name: string
}

export type CommunicationDripCampaignCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  churchId?: Prisma.SortOrder
  name?: Prisma.SortOrder
  description?: Prisma.SortOrder
  status?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type CommunicationDripCampaignMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  churchId?: Prisma.SortOrder
  name?: Prisma.SortOrder
  description?: Prisma.SortOrder
  status?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type CommunicationDripCampaignMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  churchId?: Prisma.SortOrder
  name?: Prisma.SortOrder
  description?: Prisma.SortOrder
  status?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type CommunicationDripCampaignScalarRelationFilter = {
  is?: Prisma.CommunicationDripCampaignWhereInput
  isNot?: Prisma.CommunicationDripCampaignWhereInput
}

export type CommunicationDripCampaignCreateNestedManyWithoutChurchInput = {
  create?: Prisma.XOR<Prisma.CommunicationDripCampaignCreateWithoutChurchInput, Prisma.CommunicationDripCampaignUncheckedCreateWithoutChurchInput> | Prisma.CommunicationDripCampaignCreateWithoutChurchInput[] | Prisma.CommunicationDripCampaignUncheckedCreateWithoutChurchInput[]
  connectOrCreate?: Prisma.CommunicationDripCampaignCreateOrConnectWithoutChurchInput | Prisma.CommunicationDripCampaignCreateOrConnectWithoutChurchInput[]
  createMany?: Prisma.CommunicationDripCampaignCreateManyChurchInputEnvelope
  connect?: Prisma.CommunicationDripCampaignWhereUniqueInput | Prisma.CommunicationDripCampaignWhereUniqueInput[]
}

export type CommunicationDripCampaignUncheckedCreateNestedManyWithoutChurchInput = {
  create?: Prisma.XOR<Prisma.CommunicationDripCampaignCreateWithoutChurchInput, Prisma.CommunicationDripCampaignUncheckedCreateWithoutChurchInput> | Prisma.CommunicationDripCampaignCreateWithoutChurchInput[] | Prisma.CommunicationDripCampaignUncheckedCreateWithoutChurchInput[]
  connectOrCreate?: Prisma.CommunicationDripCampaignCreateOrConnectWithoutChurchInput | Prisma.CommunicationDripCampaignCreateOrConnectWithoutChurchInput[]
  createMany?: Prisma.CommunicationDripCampaignCreateManyChurchInputEnvelope
  connect?: Prisma.CommunicationDripCampaignWhereUniqueInput | Prisma.CommunicationDripCampaignWhereUniqueInput[]
}

export type CommunicationDripCampaignUpdateManyWithoutChurchNestedInput = {
  create?: Prisma.XOR<Prisma.CommunicationDripCampaignCreateWithoutChurchInput, Prisma.CommunicationDripCampaignUncheckedCreateWithoutChurchInput> | Prisma.CommunicationDripCampaignCreateWithoutChurchInput[] | Prisma.CommunicationDripCampaignUncheckedCreateWithoutChurchInput[]
  connectOrCreate?: Prisma.CommunicationDripCampaignCreateOrConnectWithoutChurchInput | Prisma.CommunicationDripCampaignCreateOrConnectWithoutChurchInput[]
  upsert?: Prisma.CommunicationDripCampaignUpsertWithWhereUniqueWithoutChurchInput | Prisma.CommunicationDripCampaignUpsertWithWhereUniqueWithoutChurchInput[]
  createMany?: Prisma.CommunicationDripCampaignCreateManyChurchInputEnvelope
  set?: Prisma.CommunicationDripCampaignWhereUniqueInput | Prisma.CommunicationDripCampaignWhereUniqueInput[]
  disconnect?: Prisma.CommunicationDripCampaignWhereUniqueInput | Prisma.CommunicationDripCampaignWhereUniqueInput[]
  delete?: Prisma.CommunicationDripCampaignWhereUniqueInput | Prisma.CommunicationDripCampaignWhereUniqueInput[]
  connect?: Prisma.CommunicationDripCampaignWhereUniqueInput | Prisma.CommunicationDripCampaignWhereUniqueInput[]
  update?: Prisma.CommunicationDripCampaignUpdateWithWhereUniqueWithoutChurchInput | Prisma.CommunicationDripCampaignUpdateWithWhereUniqueWithoutChurchInput[]
  updateMany?: Prisma.CommunicationDripCampaignUpdateManyWithWhereWithoutChurchInput | Prisma.CommunicationDripCampaignUpdateManyWithWhereWithoutChurchInput[]
  deleteMany?: Prisma.CommunicationDripCampaignScalarWhereInput | Prisma.CommunicationDripCampaignScalarWhereInput[]
}

export type CommunicationDripCampaignUncheckedUpdateManyWithoutChurchNestedInput = {
  create?: Prisma.XOR<Prisma.CommunicationDripCampaignCreateWithoutChurchInput, Prisma.CommunicationDripCampaignUncheckedCreateWithoutChurchInput> | Prisma.CommunicationDripCampaignCreateWithoutChurchInput[] | Prisma.CommunicationDripCampaignUncheckedCreateWithoutChurchInput[]
  connectOrCreate?: Prisma.CommunicationDripCampaignCreateOrConnectWithoutChurchInput | Prisma.CommunicationDripCampaignCreateOrConnectWithoutChurchInput[]
  upsert?: Prisma.CommunicationDripCampaignUpsertWithWhereUniqueWithoutChurchInput | Prisma.CommunicationDripCampaignUpsertWithWhereUniqueWithoutChurchInput[]
  createMany?: Prisma.CommunicationDripCampaignCreateManyChurchInputEnvelope
  set?: Prisma.CommunicationDripCampaignWhereUniqueInput | Prisma.CommunicationDripCampaignWhereUniqueInput[]
  disconnect?: Prisma.CommunicationDripCampaignWhereUniqueInput | Prisma.CommunicationDripCampaignWhereUniqueInput[]
  delete?: Prisma.CommunicationDripCampaignWhereUniqueInput | Prisma.CommunicationDripCampaignWhereUniqueInput[]
  connect?: Prisma.CommunicationDripCampaignWhereUniqueInput | Prisma.CommunicationDripCampaignWhereUniqueInput[]
  update?: Prisma.CommunicationDripCampaignUpdateWithWhereUniqueWithoutChurchInput | Prisma.CommunicationDripCampaignUpdateWithWhereUniqueWithoutChurchInput[]
  updateMany?: Prisma.CommunicationDripCampaignUpdateManyWithWhereWithoutChurchInput | Prisma.CommunicationDripCampaignUpdateManyWithWhereWithoutChurchInput[]
  deleteMany?: Prisma.CommunicationDripCampaignScalarWhereInput | Prisma.CommunicationDripCampaignScalarWhereInput[]
}

export type EnumDripCampaignStatusFieldUpdateOperationsInput = {
  set?: $Enums.DripCampaignStatus
}

export type CommunicationDripCampaignCreateNestedOneWithoutStepsInput = {
  create?: Prisma.XOR<Prisma.CommunicationDripCampaignCreateWithoutStepsInput, Prisma.CommunicationDripCampaignUncheckedCreateWithoutStepsInput>
  connectOrCreate?: Prisma.CommunicationDripCampaignCreateOrConnectWithoutStepsInput
  connect?: Prisma.CommunicationDripCampaignWhereUniqueInput
}

export type CommunicationDripCampaignUpdateOneRequiredWithoutStepsNestedInput = {
  create?: Prisma.XOR<Prisma.CommunicationDripCampaignCreateWithoutStepsInput, Prisma.CommunicationDripCampaignUncheckedCreateWithoutStepsInput>
  connectOrCreate?: Prisma.CommunicationDripCampaignCreateOrConnectWithoutStepsInput
  upsert?: Prisma.CommunicationDripCampaignUpsertWithoutStepsInput
  connect?: Prisma.CommunicationDripCampaignWhereUniqueInput
  update?: Prisma.XOR<Prisma.XOR<Prisma.CommunicationDripCampaignUpdateToOneWithWhereWithoutStepsInput, Prisma.CommunicationDripCampaignUpdateWithoutStepsInput>, Prisma.CommunicationDripCampaignUncheckedUpdateWithoutStepsInput>
}

export type CommunicationDripCampaignCreateNestedOneWithoutEnrollmentsInput = {
  create?: Prisma.XOR<Prisma.CommunicationDripCampaignCreateWithoutEnrollmentsInput, Prisma.CommunicationDripCampaignUncheckedCreateWithoutEnrollmentsInput>
  connectOrCreate?: Prisma.CommunicationDripCampaignCreateOrConnectWithoutEnrollmentsInput
  connect?: Prisma.CommunicationDripCampaignWhereUniqueInput
}

export type CommunicationDripCampaignUpdateOneRequiredWithoutEnrollmentsNestedInput = {
  create?: Prisma.XOR<Prisma.CommunicationDripCampaignCreateWithoutEnrollmentsInput, Prisma.CommunicationDripCampaignUncheckedCreateWithoutEnrollmentsInput>
  connectOrCreate?: Prisma.CommunicationDripCampaignCreateOrConnectWithoutEnrollmentsInput
  upsert?: Prisma.CommunicationDripCampaignUpsertWithoutEnrollmentsInput
  connect?: Prisma.CommunicationDripCampaignWhereUniqueInput
  update?: Prisma.XOR<Prisma.XOR<Prisma.CommunicationDripCampaignUpdateToOneWithWhereWithoutEnrollmentsInput, Prisma.CommunicationDripCampaignUpdateWithoutEnrollmentsInput>, Prisma.CommunicationDripCampaignUncheckedUpdateWithoutEnrollmentsInput>
}

export type CommunicationDripCampaignCreateWithoutChurchInput = {
  id?: string
  name: string
  description?: string | null
  status?: $Enums.DripCampaignStatus
  createdAt?: Date | string
  updatedAt?: Date | string
  steps?: Prisma.CommunicationDripStepCreateNestedManyWithoutCampaignInput
  enrollments?: Prisma.CommunicationDripEnrollmentCreateNestedManyWithoutCampaignInput
}

export type CommunicationDripCampaignUncheckedCreateWithoutChurchInput = {
  id?: string
  name: string
  description?: string | null
  status?: $Enums.DripCampaignStatus
  createdAt?: Date | string
  updatedAt?: Date | string
  steps?: Prisma.CommunicationDripStepUncheckedCreateNestedManyWithoutCampaignInput
  enrollments?: Prisma.CommunicationDripEnrollmentUncheckedCreateNestedManyWithoutCampaignInput
}

export type CommunicationDripCampaignCreateOrConnectWithoutChurchInput = {
  where: Prisma.CommunicationDripCampaignWhereUniqueInput
  create: Prisma.XOR<Prisma.CommunicationDripCampaignCreateWithoutChurchInput, Prisma.CommunicationDripCampaignUncheckedCreateWithoutChurchInput>
}

export type CommunicationDripCampaignCreateManyChurchInputEnvelope = {
  data: Prisma.CommunicationDripCampaignCreateManyChurchInput | Prisma.CommunicationDripCampaignCreateManyChurchInput[]
  skipDuplicates?: boolean
}

export type CommunicationDripCampaignUpsertWithWhereUniqueWithoutChurchInput = {
  where: Prisma.CommunicationDripCampaignWhereUniqueInput
  update: Prisma.XOR<Prisma.CommunicationDripCampaignUpdateWithoutChurchInput, Prisma.CommunicationDripCampaignUncheckedUpdateWithoutChurchInput>
  create: Prisma.XOR<Prisma.CommunicationDripCampaignCreateWithoutChurchInput, Prisma.CommunicationDripCampaignUncheckedCreateWithoutChurchInput>
}

export type CommunicationDripCampaignUpdateWithWhereUniqueWithoutChurchInput = {
  where: Prisma.CommunicationDripCampaignWhereUniqueInput
  data: Prisma.XOR<Prisma.CommunicationDripCampaignUpdateWithoutChurchInput, Prisma.CommunicationDripCampaignUncheckedUpdateWithoutChurchInput>
}

export type CommunicationDripCampaignUpdateManyWithWhereWithoutChurchInput = {
  where: Prisma.CommunicationDripCampaignScalarWhereInput
  data: Prisma.XOR<Prisma.CommunicationDripCampaignUpdateManyMutationInput, Prisma.CommunicationDripCampaignUncheckedUpdateManyWithoutChurchInput>
}

export type CommunicationDripCampaignScalarWhereInput = {
  AND?: Prisma.CommunicationDripCampaignScalarWhereInput | Prisma.CommunicationDripCampaignScalarWhereInput[]
  OR?: Prisma.CommunicationDripCampaignScalarWhereInput[]
  NOT?: Prisma.CommunicationDripCampaignScalarWhereInput | Prisma.CommunicationDripCampaignScalarWhereInput[]
  id?: Prisma.StringFilter<"CommunicationDripCampaign"> | string
  churchId?: Prisma.StringFilter<"CommunicationDripCampaign"> | string
  name?: Prisma.StringFilter<"CommunicationDripCampaign"> | string
  description?: Prisma.StringNullableFilter<"CommunicationDripCampaign"> | string | null
  status?: Prisma.EnumDripCampaignStatusFilter<"CommunicationDripCampaign"> | $Enums.DripCampaignStatus
  createdAt?: Prisma.DateTimeFilter<"CommunicationDripCampaign"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"CommunicationDripCampaign"> | Date | string
}

export type CommunicationDripCampaignCreateWithoutStepsInput = {
  id?: string
  name: string
  description?: string | null
  status?: $Enums.DripCampaignStatus
  createdAt?: Date | string
  updatedAt?: Date | string
  church: Prisma.ChurchCreateNestedOneWithoutDripCampaignsInput
  enrollments?: Prisma.CommunicationDripEnrollmentCreateNestedManyWithoutCampaignInput
}

export type CommunicationDripCampaignUncheckedCreateWithoutStepsInput = {
  id?: string
  churchId: string
  name: string
  description?: string | null
  status?: $Enums.DripCampaignStatus
  createdAt?: Date | string
  updatedAt?: Date | string
  enrollments?: Prisma.CommunicationDripEnrollmentUncheckedCreateNestedManyWithoutCampaignInput
}

export type CommunicationDripCampaignCreateOrConnectWithoutStepsInput = {
  where: Prisma.CommunicationDripCampaignWhereUniqueInput
  create: Prisma.XOR<Prisma.CommunicationDripCampaignCreateWithoutStepsInput, Prisma.CommunicationDripCampaignUncheckedCreateWithoutStepsInput>
}

export type CommunicationDripCampaignUpsertWithoutStepsInput = {
  update: Prisma.XOR<Prisma.CommunicationDripCampaignUpdateWithoutStepsInput, Prisma.CommunicationDripCampaignUncheckedUpdateWithoutStepsInput>
  create: Prisma.XOR<Prisma.CommunicationDripCampaignCreateWithoutStepsInput, Prisma.CommunicationDripCampaignUncheckedCreateWithoutStepsInput>
  where?: Prisma.CommunicationDripCampaignWhereInput
}

export type CommunicationDripCampaignUpdateToOneWithWhereWithoutStepsInput = {
  where?: Prisma.CommunicationDripCampaignWhereInput
  data: Prisma.XOR<Prisma.CommunicationDripCampaignUpdateWithoutStepsInput, Prisma.CommunicationDripCampaignUncheckedUpdateWithoutStepsInput>
}

export type CommunicationDripCampaignUpdateWithoutStepsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  name?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  status?: Prisma.EnumDripCampaignStatusFieldUpdateOperationsInput | $Enums.DripCampaignStatus
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  church?: Prisma.ChurchUpdateOneRequiredWithoutDripCampaignsNestedInput
  enrollments?: Prisma.CommunicationDripEnrollmentUpdateManyWithoutCampaignNestedInput
}

export type CommunicationDripCampaignUncheckedUpdateWithoutStepsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  churchId?: Prisma.StringFieldUpdateOperationsInput | string
  name?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  status?: Prisma.EnumDripCampaignStatusFieldUpdateOperationsInput | $Enums.DripCampaignStatus
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  enrollments?: Prisma.CommunicationDripEnrollmentUncheckedUpdateManyWithoutCampaignNestedInput
}

export type CommunicationDripCampaignCreateWithoutEnrollmentsInput = {
  id?: string
  name: string
  description?: string | null
  status?: $Enums.DripCampaignStatus
  createdAt?: Date | string
  updatedAt?: Date | string
  church: Prisma.ChurchCreateNestedOneWithoutDripCampaignsInput
  steps?: Prisma.CommunicationDripStepCreateNestedManyWithoutCampaignInput
}

export type CommunicationDripCampaignUncheckedCreateWithoutEnrollmentsInput = {
  id?: string
  churchId: string
  name: string
  description?: string | null
  status?: $Enums.DripCampaignStatus
  createdAt?: Date | string
  updatedAt?: Date | string
  steps?: Prisma.CommunicationDripStepUncheckedCreateNestedManyWithoutCampaignInput
}

export type CommunicationDripCampaignCreateOrConnectWithoutEnrollmentsInput = {
  where: Prisma.CommunicationDripCampaignWhereUniqueInput
  create: Prisma.XOR<Prisma.CommunicationDripCampaignCreateWithoutEnrollmentsInput, Prisma.CommunicationDripCampaignUncheckedCreateWithoutEnrollmentsInput>
}

export type CommunicationDripCampaignUpsertWithoutEnrollmentsInput = {
  update: Prisma.XOR<Prisma.CommunicationDripCampaignUpdateWithoutEnrollmentsInput, Prisma.CommunicationDripCampaignUncheckedUpdateWithoutEnrollmentsInput>
  create: Prisma.XOR<Prisma.CommunicationDripCampaignCreateWithoutEnrollmentsInput, Prisma.CommunicationDripCampaignUncheckedCreateWithoutEnrollmentsInput>
  where?: Prisma.CommunicationDripCampaignWhereInput
}

export type CommunicationDripCampaignUpdateToOneWithWhereWithoutEnrollmentsInput = {
  where?: Prisma.CommunicationDripCampaignWhereInput
  data: Prisma.XOR<Prisma.CommunicationDripCampaignUpdateWithoutEnrollmentsInput, Prisma.CommunicationDripCampaignUncheckedUpdateWithoutEnrollmentsInput>
}

export type CommunicationDripCampaignUpdateWithoutEnrollmentsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  name?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  status?: Prisma.EnumDripCampaignStatusFieldUpdateOperationsInput | $Enums.DripCampaignStatus
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  church?: Prisma.ChurchUpdateOneRequiredWithoutDripCampaignsNestedInput
  steps?: Prisma.CommunicationDripStepUpdateManyWithoutCampaignNestedInput
}

export type CommunicationDripCampaignUncheckedUpdateWithoutEnrollmentsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  churchId?: Prisma.StringFieldUpdateOperationsInput | string
  name?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  status?: Prisma.EnumDripCampaignStatusFieldUpdateOperationsInput | $Enums.DripCampaignStatus
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  steps?: Prisma.CommunicationDripStepUncheckedUpdateManyWithoutCampaignNestedInput
}

export type CommunicationDripCampaignCreateManyChurchInput = {
  id?: string
  name: string
  description?: string | null
  status?: $Enums.DripCampaignStatus
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type CommunicationDripCampaignUpdateWithoutChurchInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  name?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  status?: Prisma.EnumDripCampaignStatusFieldUpdateOperationsInput | $Enums.DripCampaignStatus
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  steps?: Prisma.CommunicationDripStepUpdateManyWithoutCampaignNestedInput
  enrollments?: Prisma.CommunicationDripEnrollmentUpdateManyWithoutCampaignNestedInput
}

export type CommunicationDripCampaignUncheckedUpdateWithoutChurchInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  name?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  status?: Prisma.EnumDripCampaignStatusFieldUpdateOperationsInput | $Enums.DripCampaignStatus
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  steps?: Prisma.CommunicationDripStepUncheckedUpdateManyWithoutCampaignNestedInput
  enrollments?: Prisma.CommunicationDripEnrollmentUncheckedUpdateManyWithoutCampaignNestedInput
}

export type CommunicationDripCampaignUncheckedUpdateManyWithoutChurchInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  name?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  status?: Prisma.EnumDripCampaignStatusFieldUpdateOperationsInput | $Enums.DripCampaignStatus
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}


/**
 * Count Type CommunicationDripCampaignCountOutputType
 */

export type CommunicationDripCampaignCountOutputType = {
  steps: number
  enrollments: number
}

export type CommunicationDripCampaignCountOutputTypeSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  steps?: boolean | CommunicationDripCampaignCountOutputTypeCountStepsArgs
  enrollments?: boolean | CommunicationDripCampaignCountOutputTypeCountEnrollmentsArgs
}

/**
 * CommunicationDripCampaignCountOutputType without action
 */
export type CommunicationDripCampaignCountOutputTypeDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CommunicationDripCampaignCountOutputType
   */
  select?: Prisma.CommunicationDripCampaignCountOutputTypeSelect<ExtArgs> | null
}

/**
 * CommunicationDripCampaignCountOutputType without action
 */
export type CommunicationDripCampaignCountOutputTypeCountStepsArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.CommunicationDripStepWhereInput
}

/**
 * CommunicationDripCampaignCountOutputType without action
 */
export type CommunicationDripCampaignCountOutputTypeCountEnrollmentsArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.CommunicationDripEnrollmentWhereInput
}


export type CommunicationDripCampaignSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  churchId?: boolean
  name?: boolean
  description?: boolean
  status?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  church?: boolean | Prisma.ChurchDefaultArgs<ExtArgs>
  steps?: boolean | Prisma.CommunicationDripCampaign$stepsArgs<ExtArgs>
  enrollments?: boolean | Prisma.CommunicationDripCampaign$enrollmentsArgs<ExtArgs>
  _count?: boolean | Prisma.CommunicationDripCampaignCountOutputTypeDefaultArgs<ExtArgs>
}, ExtArgs["result"]["communicationDripCampaign"]>

export type CommunicationDripCampaignSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  churchId?: boolean
  name?: boolean
  description?: boolean
  status?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  church?: boolean | Prisma.ChurchDefaultArgs<ExtArgs>
}, ExtArgs["result"]["communicationDripCampaign"]>

export type CommunicationDripCampaignSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  churchId?: boolean
  name?: boolean
  description?: boolean
  status?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  church?: boolean | Prisma.ChurchDefaultArgs<ExtArgs>
}, ExtArgs["result"]["communicationDripCampaign"]>

export type CommunicationDripCampaignSelectScalar = {
  id?: boolean
  churchId?: boolean
  name?: boolean
  description?: boolean
  status?: boolean
  createdAt?: boolean
  updatedAt?: boolean
}

export type CommunicationDripCampaignOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "churchId" | "name" | "description" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["communicationDripCampaign"]>
export type CommunicationDripCampaignInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  church?: boolean | Prisma.ChurchDefaultArgs<ExtArgs>
  steps?: boolean | Prisma.CommunicationDripCampaign$stepsArgs<ExtArgs>
  enrollments?: boolean | Prisma.CommunicationDripCampaign$enrollmentsArgs<ExtArgs>
  _count?: boolean | Prisma.CommunicationDripCampaignCountOutputTypeDefaultArgs<ExtArgs>
}
export type CommunicationDripCampaignIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  church?: boolean | Prisma.ChurchDefaultArgs<ExtArgs>
}
export type CommunicationDripCampaignIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  church?: boolean | Prisma.ChurchDefaultArgs<ExtArgs>
}

export type $CommunicationDripCampaignPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "CommunicationDripCampaign"
  objects: {
    church: Prisma.$ChurchPayload<ExtArgs>
    steps: Prisma.$CommunicationDripStepPayload<ExtArgs>[]
    enrollments: Prisma.$CommunicationDripEnrollmentPayload<ExtArgs>[]
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: string
    churchId: string
    name: string
    description: string | null
    status: $Enums.DripCampaignStatus
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["communicationDripCampaign"]>
  composites: {}
}

export type CommunicationDripCampaignGetPayload<S extends boolean | null | undefined | CommunicationDripCampaignDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$CommunicationDripCampaignPayload, S>

export type CommunicationDripCampaignCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<CommunicationDripCampaignFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: CommunicationDripCampaignCountAggregateInputType | true
  }

export interface CommunicationDripCampaignDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommunicationDripCampaign'], meta: { name: 'CommunicationDripCampaign' } }
  /**
   * Find zero or one CommunicationDripCampaign that matches the filter.
   * @param {CommunicationDripCampaignFindUniqueArgs} args - Arguments to find a CommunicationDripCampaign
   * @example
   * // Get one CommunicationDripCampaign
   * const communicationDripCampaign = await prisma.communicationDripCampaign.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends CommunicationDripCampaignFindUniqueArgs>(args: Prisma.SelectSubset<T, CommunicationDripCampaignFindUniqueArgs<ExtArgs>>): Prisma.Prisma__CommunicationDripCampaignClient<runtime.Types.Result.GetResult<Prisma.$CommunicationDripCampaignPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one CommunicationDripCampaign that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {CommunicationDripCampaignFindUniqueOrThrowArgs} args - Arguments to find a CommunicationDripCampaign
   * @example
   * // Get one CommunicationDripCampaign
   * const communicationDripCampaign = await prisma.communicationDripCampaign.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends CommunicationDripCampaignFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, CommunicationDripCampaignFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__CommunicationDripCampaignClient<runtime.Types.Result.GetResult<Prisma.$CommunicationDripCampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first CommunicationDripCampaign that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {CommunicationDripCampaignFindFirstArgs} args - Arguments to find a CommunicationDripCampaign
   * @example
   * // Get one CommunicationDripCampaign
   * const communicationDripCampaign = await prisma.communicationDripCampaign.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends CommunicationDripCampaignFindFirstArgs>(args?: Prisma.SelectSubset<T, CommunicationDripCampaignFindFirstArgs<ExtArgs>>): Prisma.Prisma__CommunicationDripCampaignClient<runtime.Types.Result.GetResult<Prisma.$CommunicationDripCampaignPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first CommunicationDripCampaign that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {CommunicationDripCampaignFindFirstOrThrowArgs} args - Arguments to find a CommunicationDripCampaign
   * @example
   * // Get one CommunicationDripCampaign
   * const communicationDripCampaign = await prisma.communicationDripCampaign.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends CommunicationDripCampaignFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, CommunicationDripCampaignFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__CommunicationDripCampaignClient<runtime.Types.Result.GetResult<Prisma.$CommunicationDripCampaignPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more CommunicationDripCampaigns that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {CommunicationDripCampaignFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all CommunicationDripCampaigns
   * const communicationDripCampaigns = await prisma.communicationDripCampaign.findMany()
   * 
   * // Get first 10 CommunicationDripCampaigns
   * const communicationDripCampaigns = await prisma.communicationDripCampaign.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const communicationDripCampaignWithIdOnly = await prisma.communicationDripCampaign.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends CommunicationDripCampaignFindManyArgs>(args?: Prisma.SelectSubset<T, CommunicationDripCampaignFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$CommunicationDripCampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a CommunicationDripCampaign.
   * @param {CommunicationDripCampaignCreateArgs} args - Arguments to create a CommunicationDripCampaign.
   * @example
   * // Create one CommunicationDripCampaign
   * const CommunicationDripCampaign = await prisma.communicationDripCampaign.create({
   *   data: {
   *     // ... data to create a CommunicationDripCampaign
   *   }
   * })
   * 
   */
  create<T extends CommunicationDripCampaignCreateArgs>(args: Prisma.SelectSubset<T, CommunicationDripCampaignCreateArgs<ExtArgs>>): Prisma.Prisma__CommunicationDripCampaignClient<runtime.Types.Result.GetResult<Prisma.$CommunicationDripCampaignPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many CommunicationDripCampaigns.
   * @param {CommunicationDripCampaignCreateManyArgs} args - Arguments to create many CommunicationDripCampaigns.
   * @example
   * // Create many CommunicationDripCampaigns
   * const communicationDripCampaign = await prisma.communicationDripCampaign.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends CommunicationDripCampaignCreateManyArgs>(args?: Prisma.SelectSubset<T, CommunicationDripCampaignCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many CommunicationDripCampaigns and returns the data saved in the database.
   * @param {CommunicationDripCampaignCreateManyAndReturnArgs} args - Arguments to create many CommunicationDripCampaigns.
   * @example
   * // Create many CommunicationDripCampaigns
   * const communicationDripCampaign = await prisma.communicationDripCampaign.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many CommunicationDripCampaigns and only return the `id`
   * const communicationDripCampaignWithIdOnly = await prisma.communicationDripCampaign.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends CommunicationDripCampaignCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, CommunicationDripCampaignCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$CommunicationDripCampaignPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a CommunicationDripCampaign.
   * @param {CommunicationDripCampaignDeleteArgs} args - Arguments to delete one CommunicationDripCampaign.
   * @example
   * // Delete one CommunicationDripCampaign
   * const CommunicationDripCampaign = await prisma.communicationDripCampaign.delete({
   *   where: {
   *     // ... filter to delete one CommunicationDripCampaign
   *   }
   * })
   * 
   */
  delete<T extends CommunicationDripCampaignDeleteArgs>(args: Prisma.SelectSubset<T, CommunicationDripCampaignDeleteArgs<ExtArgs>>): Prisma.Prisma__CommunicationDripCampaignClient<runtime.Types.Result.GetResult<Prisma.$CommunicationDripCampaignPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one CommunicationDripCampaign.
   * @param {CommunicationDripCampaignUpdateArgs} args - Arguments to update one CommunicationDripCampaign.
   * @example
   * // Update one CommunicationDripCampaign
   * const communicationDripCampaign = await prisma.communicationDripCampaign.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends CommunicationDripCampaignUpdateArgs>(args: Prisma.SelectSubset<T, CommunicationDripCampaignUpdateArgs<ExtArgs>>): Prisma.Prisma__CommunicationDripCampaignClient<runtime.Types.Result.GetResult<Prisma.$CommunicationDripCampaignPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more CommunicationDripCampaigns.
   * @param {CommunicationDripCampaignDeleteManyArgs} args - Arguments to filter CommunicationDripCampaigns to delete.
   * @example
   * // Delete a few CommunicationDripCampaigns
   * const { count } = await prisma.communicationDripCampaign.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends CommunicationDripCampaignDeleteManyArgs>(args?: Prisma.SelectSubset<T, CommunicationDripCampaignDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more CommunicationDripCampaigns.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {CommunicationDripCampaignUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many CommunicationDripCampaigns
   * const communicationDripCampaign = await prisma.communicationDripCampaign.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends CommunicationDripCampaignUpdateManyArgs>(args: Prisma.SelectSubset<T, CommunicationDripCampaignUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more CommunicationDripCampaigns and returns the data updated in the database.
   * @param {CommunicationDripCampaignUpdateManyAndReturnArgs} args - Arguments to update many CommunicationDripCampaigns.
   * @example
   * // Update many CommunicationDripCampaigns
   * const communicationDripCampaign = await prisma.communicationDripCampaign.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more CommunicationDripCampaigns and only return the `id`
   * const communicationDripCampaignWithIdOnly = await prisma.communicationDripCampaign.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends CommunicationDripCampaignUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, CommunicationDripCampaignUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$CommunicationDripCampaignPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one CommunicationDripCampaign.
   * @param {CommunicationDripCampaignUpsertArgs} args - Arguments to update or create a CommunicationDripCampaign.
   * @example
   * // Update or create a CommunicationDripCampaign
   * const communicationDripCampaign = await prisma.communicationDripCampaign.upsert({
   *   create: {
   *     // ... data to create a CommunicationDripCampaign
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the CommunicationDripCampaign we want to update
   *   }
   * })
   */
  upsert<T extends CommunicationDripCampaignUpsertArgs>(args: Prisma.SelectSubset<T, CommunicationDripCampaignUpsertArgs<ExtArgs>>): Prisma.Prisma__CommunicationDripCampaignClient<runtime.Types.Result.GetResult<Prisma.$CommunicationDripCampaignPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of CommunicationDripCampaigns.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {CommunicationDripCampaignCountArgs} args - Arguments to filter CommunicationDripCampaigns to count.
   * @example
   * // Count the number of CommunicationDripCampaigns
   * const count = await prisma.communicationDripCampaign.count({
   *   where: {
   *     // ... the filter for the CommunicationDripCampaigns we want to count
   *   }
   * })
  **/
  count<T extends CommunicationDripCampaignCountArgs>(
    args?: Prisma.Subset<T, CommunicationDripCampaignCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], CommunicationDripCampaignCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a CommunicationDripCampaign.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {CommunicationDripCampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends CommunicationDripCampaignAggregateArgs>(args: Prisma.Subset<T, CommunicationDripCampaignAggregateArgs>): Prisma.PrismaPromise<GetCommunicationDripCampaignAggregateType<T>>

  /**
   * Group by CommunicationDripCampaign.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {CommunicationDripCampaignGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends CommunicationDripCampaignGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: CommunicationDripCampaignGroupByArgs['orderBy'] }
      : { orderBy?: CommunicationDripCampaignGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, CommunicationDripCampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommunicationDripCampaignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the CommunicationDripCampaign model
 */
readonly fields: CommunicationDripCampaignFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for CommunicationDripCampaign.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__CommunicationDripCampaignClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  church<T extends Prisma.ChurchDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.ChurchDefaultArgs<ExtArgs>>): Prisma.Prisma__ChurchClient<runtime.Types.Result.GetResult<Prisma.$ChurchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  steps<T extends Prisma.CommunicationDripCampaign$stepsArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.CommunicationDripCampaign$stepsArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$CommunicationDripStepPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
  enrollments<T extends Prisma.CommunicationDripCampaign$enrollmentsArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.CommunicationDripCampaign$enrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$CommunicationDripEnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the CommunicationDripCampaign model
 */
export interface CommunicationDripCampaignFieldRefs {
  readonly id: Prisma.FieldRef<"CommunicationDripCampaign", 'String'>
  readonly churchId: Prisma.FieldRef<"CommunicationDripCampaign", 'String'>
  readonly name: Prisma.FieldRef<"CommunicationDripCampaign", 'String'>
  readonly description: Prisma.FieldRef<"CommunicationDripCampaign", 'String'>
  readonly status: Prisma.FieldRef<"CommunicationDripCampaign", 'DripCampaignStatus'>
  readonly createdAt: Prisma.FieldRef<"CommunicationDripCampaign", 'DateTime'>
  readonly updatedAt: Prisma.FieldRef<"CommunicationDripCampaign", 'DateTime'>
}
    

// Custom InputTypes
/**
 * CommunicationDripCampaign findUnique
 */
export type CommunicationDripCampaignFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CommunicationDripCampaign
   */
  select?: Prisma.CommunicationDripCampaignSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CommunicationDripCampaign
   */
  omit?: Prisma.CommunicationDripCampaignOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CommunicationDripCampaignInclude<ExtArgs> | null
  /**
   * Filter, which CommunicationDripCampaign to fetch.
   */
  where: Prisma.CommunicationDripCampaignWhereUniqueInput
}

/**
 * CommunicationDripCampaign findUniqueOrThrow
 */
export type CommunicationDripCampaignFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CommunicationDripCampaign
   */
  select?: Prisma.CommunicationDripCampaignSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CommunicationDripCampaign
   */
  omit?: Prisma.CommunicationDripCampaignOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CommunicationDripCampaignInclude<ExtArgs> | null
  /**
   * Filter, which CommunicationDripCampaign to fetch.
   */
  where: Prisma.CommunicationDripCampaignWhereUniqueInput
}

/**
 * CommunicationDripCampaign findFirst
 */
export type CommunicationDripCampaignFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CommunicationDripCampaign
   */
  select?: Prisma.CommunicationDripCampaignSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CommunicationDripCampaign
   */
  omit?: Prisma.CommunicationDripCampaignOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CommunicationDripCampaignInclude<ExtArgs> | null
  /**
   * Filter, which CommunicationDripCampaign to fetch.
   */
  where?: Prisma.CommunicationDripCampaignWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of CommunicationDripCampaigns to fetch.
   */
  orderBy?: Prisma.CommunicationDripCampaignOrderByWithRelationInput | Prisma.CommunicationDripCampaignOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for CommunicationDripCampaigns.
   */
  cursor?: Prisma.CommunicationDripCampaignWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` CommunicationDripCampaigns from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` CommunicationDripCampaigns.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of CommunicationDripCampaigns.
   */
  distinct?: Prisma.CommunicationDripCampaignScalarFieldEnum | Prisma.CommunicationDripCampaignScalarFieldEnum[]
}

/**
 * CommunicationDripCampaign findFirstOrThrow
 */
export type CommunicationDripCampaignFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CommunicationDripCampaign
   */
  select?: Prisma.CommunicationDripCampaignSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CommunicationDripCampaign
   */
  omit?: Prisma.CommunicationDripCampaignOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CommunicationDripCampaignInclude<ExtArgs> | null
  /**
   * Filter, which CommunicationDripCampaign to fetch.
   */
  where?: Prisma.CommunicationDripCampaignWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of CommunicationDripCampaigns to fetch.
   */
  orderBy?: Prisma.CommunicationDripCampaignOrderByWithRelationInput | Prisma.CommunicationDripCampaignOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for CommunicationDripCampaigns.
   */
  cursor?: Prisma.CommunicationDripCampaignWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` CommunicationDripCampaigns from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` CommunicationDripCampaigns.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of CommunicationDripCampaigns.
   */
  distinct?: Prisma.CommunicationDripCampaignScalarFieldEnum | Prisma.CommunicationDripCampaignScalarFieldEnum[]
}

/**
 * CommunicationDripCampaign findMany
 */
export type CommunicationDripCampaignFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CommunicationDripCampaign
   */
  select?: Prisma.CommunicationDripCampaignSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CommunicationDripCampaign
   */
  omit?: Prisma.CommunicationDripCampaignOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CommunicationDripCampaignInclude<ExtArgs> | null
  /**
   * Filter, which CommunicationDripCampaigns to fetch.
   */
  where?: Prisma.CommunicationDripCampaignWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of CommunicationDripCampaigns to fetch.
   */
  orderBy?: Prisma.CommunicationDripCampaignOrderByWithRelationInput | Prisma.CommunicationDripCampaignOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing CommunicationDripCampaigns.
   */
  cursor?: Prisma.CommunicationDripCampaignWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` CommunicationDripCampaigns from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` CommunicationDripCampaigns.
   */
  skip?: number
  distinct?: Prisma.CommunicationDripCampaignScalarFieldEnum | Prisma.CommunicationDripCampaignScalarFieldEnum[]
}

/**
 * CommunicationDripCampaign create
 */
export type CommunicationDripCampaignCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CommunicationDripCampaign
   */
  select?: Prisma.CommunicationDripCampaignSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CommunicationDripCampaign
   */
  omit?: Prisma.CommunicationDripCampaignOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CommunicationDripCampaignInclude<ExtArgs> | null
  /**
   * The data needed to create a CommunicationDripCampaign.
   */
  data: Prisma.XOR<Prisma.CommunicationDripCampaignCreateInput, Prisma.CommunicationDripCampaignUncheckedCreateInput>
}

/**
 * CommunicationDripCampaign createMany
 */
export type CommunicationDripCampaignCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many CommunicationDripCampaigns.
   */
  data: Prisma.CommunicationDripCampaignCreateManyInput | Prisma.CommunicationDripCampaignCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * CommunicationDripCampaign createManyAndReturn
 */
export type CommunicationDripCampaignCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CommunicationDripCampaign
   */
  select?: Prisma.CommunicationDripCampaignSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the CommunicationDripCampaign
   */
  omit?: Prisma.CommunicationDripCampaignOmit<ExtArgs> | null
  /**
   * The data used to create many CommunicationDripCampaigns.
   */
  data: Prisma.CommunicationDripCampaignCreateManyInput | Prisma.CommunicationDripCampaignCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CommunicationDripCampaignIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * CommunicationDripCampaign update
 */
export type CommunicationDripCampaignUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CommunicationDripCampaign
   */
  select?: Prisma.CommunicationDripCampaignSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CommunicationDripCampaign
   */
  omit?: Prisma.CommunicationDripCampaignOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CommunicationDripCampaignInclude<ExtArgs> | null
  /**
   * The data needed to update a CommunicationDripCampaign.
   */
  data: Prisma.XOR<Prisma.CommunicationDripCampaignUpdateInput, Prisma.CommunicationDripCampaignUncheckedUpdateInput>
  /**
   * Choose, which CommunicationDripCampaign to update.
   */
  where: Prisma.CommunicationDripCampaignWhereUniqueInput
}

/**
 * CommunicationDripCampaign updateMany
 */
export type CommunicationDripCampaignUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update CommunicationDripCampaigns.
   */
  data: Prisma.XOR<Prisma.CommunicationDripCampaignUpdateManyMutationInput, Prisma.CommunicationDripCampaignUncheckedUpdateManyInput>
  /**
   * Filter which CommunicationDripCampaigns to update
   */
  where?: Prisma.CommunicationDripCampaignWhereInput
  /**
   * Limit how many CommunicationDripCampaigns to update.
   */
  limit?: number
}

/**
 * CommunicationDripCampaign updateManyAndReturn
 */
export type CommunicationDripCampaignUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CommunicationDripCampaign
   */
  select?: Prisma.CommunicationDripCampaignSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the CommunicationDripCampaign
   */
  omit?: Prisma.CommunicationDripCampaignOmit<ExtArgs> | null
  /**
   * The data used to update CommunicationDripCampaigns.
   */
  data: Prisma.XOR<Prisma.CommunicationDripCampaignUpdateManyMutationInput, Prisma.CommunicationDripCampaignUncheckedUpdateManyInput>
  /**
   * Filter which CommunicationDripCampaigns to update
   */
  where?: Prisma.CommunicationDripCampaignWhereInput
  /**
   * Limit how many CommunicationDripCampaigns to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CommunicationDripCampaignIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * CommunicationDripCampaign upsert
 */
export type CommunicationDripCampaignUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CommunicationDripCampaign
   */
  select?: Prisma.CommunicationDripCampaignSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CommunicationDripCampaign
   */
  omit?: Prisma.CommunicationDripCampaignOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CommunicationDripCampaignInclude<ExtArgs> | null
  /**
   * The filter to search for the CommunicationDripCampaign to update in case it exists.
   */
  where: Prisma.CommunicationDripCampaignWhereUniqueInput
  /**
   * In case the CommunicationDripCampaign found by the `where` argument doesn't exist, create a new CommunicationDripCampaign with this data.
   */
  create: Prisma.XOR<Prisma.CommunicationDripCampaignCreateInput, Prisma.CommunicationDripCampaignUncheckedCreateInput>
  /**
   * In case the CommunicationDripCampaign was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.CommunicationDripCampaignUpdateInput, Prisma.CommunicationDripCampaignUncheckedUpdateInput>
}

/**
 * CommunicationDripCampaign delete
 */
export type CommunicationDripCampaignDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CommunicationDripCampaign
   */
  select?: Prisma.CommunicationDripCampaignSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CommunicationDripCampaign
   */
  omit?: Prisma.CommunicationDripCampaignOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CommunicationDripCampaignInclude<ExtArgs> | null
  /**
   * Filter which CommunicationDripCampaign to delete.
   */
  where: Prisma.CommunicationDripCampaignWhereUniqueInput
}

/**
 * CommunicationDripCampaign deleteMany
 */
export type CommunicationDripCampaignDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which CommunicationDripCampaigns to delete
   */
  where?: Prisma.CommunicationDripCampaignWhereInput
  /**
   * Limit how many CommunicationDripCampaigns to delete.
   */
  limit?: number
}

/**
 * CommunicationDripCampaign.steps
 */
export type CommunicationDripCampaign$stepsArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CommunicationDripStep
   */
  select?: Prisma.CommunicationDripStepSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CommunicationDripStep
   */
  omit?: Prisma.CommunicationDripStepOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CommunicationDripStepInclude<ExtArgs> | null
  where?: Prisma.CommunicationDripStepWhereInput
  orderBy?: Prisma.CommunicationDripStepOrderByWithRelationInput | Prisma.CommunicationDripStepOrderByWithRelationInput[]
  cursor?: Prisma.CommunicationDripStepWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Prisma.CommunicationDripStepScalarFieldEnum | Prisma.CommunicationDripStepScalarFieldEnum[]
}

/**
 * CommunicationDripCampaign.enrollments
 */
export type CommunicationDripCampaign$enrollmentsArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CommunicationDripEnrollment
   */
  select?: Prisma.CommunicationDripEnrollmentSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CommunicationDripEnrollment
   */
  omit?: Prisma.CommunicationDripEnrollmentOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CommunicationDripEnrollmentInclude<ExtArgs> | null
  where?: Prisma.CommunicationDripEnrollmentWhereInput
  orderBy?: Prisma.CommunicationDripEnrollmentOrderByWithRelationInput | Prisma.CommunicationDripEnrollmentOrderByWithRelationInput[]
  cursor?: Prisma.CommunicationDripEnrollmentWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Prisma.CommunicationDripEnrollmentScalarFieldEnum | Prisma.CommunicationDripEnrollmentScalarFieldEnum[]
}

/**
 * CommunicationDripCampaign without action
 */
export type CommunicationDripCampaignDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CommunicationDripCampaign
   */
  select?: Prisma.CommunicationDripCampaignSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CommunicationDripCampaign
   */
  omit?: Prisma.CommunicationDripCampaignOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CommunicationDripCampaignInclude<ExtArgs> | null
}
