
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * WARNING: This is an internal file that is subject to change!
 *
 * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘
 *
 * All exports from this file are wrapped under a `Prisma` namespace object in the client.ts file.
 * While this enables partial backward compatibility, it is not part of the stable public API.
 *
 * If you are looking for your Models, Enums, and Input Types, please import them from the respective
 * model files in the `model` directory!
 */

import * as runtime from "@prisma/client/runtime/client"
import type * as Prisma from "../models"
import { type PrismaClient } from "./class"

export type * from '../models'

export type DMMF = typeof runtime.DMMF

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

/**
 * Prisma Errors
 */

export const PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
export type PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError

export const PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
export type PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError

export const PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
export type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError

export const PrismaClientInitializationError = runtime.PrismaClientInitializationError
export type PrismaClientInitializationError = runtime.PrismaClientInitializationError

export const PrismaClientValidationError = runtime.PrismaClientValidationError
export type PrismaClientValidationError = runtime.PrismaClientValidationError

/**
 * Re-export of sql-template-tag
 */
export const sql = runtime.sqltag
export const empty = runtime.empty
export const join = runtime.join
export const raw = runtime.raw
export const Sql = runtime.Sql
export type Sql = runtime.Sql



/**
 * Decimal.js
 */
export const Decimal = runtime.Decimal
export type Decimal = runtime.Decimal

export type DecimalJsLike = runtime.DecimalJsLike

/**
* Extensions
*/
export type Extension = runtime.Types.Extensions.UserArgs
export const getExtensionContext = runtime.Extensions.getExtensionContext
export type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<T, F>
export type Payload<T, F extends runtime.Operation = never> = runtime.Types.Public.Payload<T, F>
export type Result<T, A, F extends runtime.Operation> = runtime.Types.Public.Result<T, A, F>
export type Exact<A, W> = runtime.Types.Public.Exact<A, W>

export type PrismaVersion = {
  client: string
  engine: string
}

/**
 * Prisma Client JS version: 7.3.0
 * Query Engine version: 9d6ad21cbbceab97458517b147a6a09ff43aa735
 */
export const prismaVersion: PrismaVersion = {
  client: "7.3.0",
  engine: "9d6ad21cbbceab97458517b147a6a09ff43aa735"
}

/**
 * Utility Types
 */

export type Bytes = runtime.Bytes
export type JsonObject = runtime.JsonObject
export type JsonArray = runtime.JsonArray
export type JsonValue = runtime.JsonValue
export type InputJsonObject = runtime.InputJsonObject
export type InputJsonArray = runtime.InputJsonArray
export type InputJsonValue = runtime.InputJsonValue


export const NullTypes = {
  DbNull: runtime.NullTypes.DbNull as (new (secret: never) => typeof runtime.DbNull),
  JsonNull: runtime.NullTypes.JsonNull as (new (secret: never) => typeof runtime.JsonNull),
  AnyNull: runtime.NullTypes.AnyNull as (new (secret: never) => typeof runtime.AnyNull),
}
/**
 * Helper for filtering JSON entries that have `null` on the database (empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const DbNull = runtime.DbNull

/**
 * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const JsonNull = runtime.JsonNull

/**
 * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const AnyNull = runtime.AnyNull


type SelectAndInclude = {
  select: any
  include: any
}

type SelectAndOmit = {
  select: any
  omit: any
}

/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
};

export type Enumerable<T> = T | Array<T>;

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};

/**
 * SelectSubset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
 * Additionally, it validates, if both select and include are present. If the case, it errors.
 */
export type SelectSubset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {})

/**
 * Subset + Intersection
 * @desc From `T` pick properties that exist in `U` and intersect `K`
 */
export type SubsetIntersection<T, U, K> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  K

type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */
export type XOR<T, U> =
  T extends object ?
  U extends object ?
    (Without<T, U> & U) | (Without<U, T> & T)
  : U : T


/**
 * Is T a Record?
 */
type IsObject<T extends any> = T extends Array<any>
? False
: T extends Date
? False
: T extends Uint8Array
? False
: T extends BigInt
? False
: T extends object
? True
: False


/**
 * If it's T[], return T
 */
export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

/**
 * From ts-toolbelt
 */

type __Either<O extends object, K extends Key> = Omit<O, K> &
  {
    // Merge all but K
    [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
  }[K]

type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

type _Either<
  O extends object,
  K extends Key,
  strict extends Boolean
> = {
  1: EitherStrict<O, K>
  0: EitherLoose<O, K>
}[strict]

export type Either<
  O extends object,
  K extends Key,
  strict extends Boolean = 1
> = O extends unknown ? _Either<O, K, strict> : never

export type Union = any

export type PatchUndefined<O extends object, O1 extends object> = {
  [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
} & {}

/** Helper Types for "Merge" **/
export type IntersectOf<U extends Union> = (
  U extends unknown ? (k: U) => void : never
) extends (k: infer I) => void
  ? I
  : never

export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
} & {};

type _Merge<U extends object> = IntersectOf<Overwrite<U, {
    [K in keyof U]-?: At<U, K>;
}>>;

type Key = string | number | symbol;
type AtStrict<O extends object, K extends Key> = O[K & keyof O];
type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
}[strict];

export type ComputeRaw<A extends any> = A extends Function ? A : {
  [K in keyof A]: A[K];
} & {};

export type OptionalFlat<O> = {
  [K in keyof O]?: O[K];
} & {};

type _Record<K extends keyof any, T> = {
  [P in K]: T;
};

// cause typescript not to expand types and preserve names
type NoExpand<T> = T extends unknown ? T : never;

// this type assumes the passed object is entirely optional
export type AtLeast<O extends object, K extends string> = NoExpand<
  O extends unknown
  ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
    | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
  : never>;

type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
/** End Helper Types for "Merge" **/

export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

export type Boolean = True | False

export type True = 1

export type False = 0

export type Not<B extends Boolean> = {
  0: 1
  1: 0
}[B]

export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
  ? 0 // anything `never` is false
  : A1 extends A2
  ? 1
  : 0

export type Has<U extends Union, U1 extends Union> = Not<
  Extends<Exclude<U1, U>, U1>
>

export type Or<B1 extends Boolean, B2 extends Boolean> = {
  0: {
    0: 0
    1: 1
  }
  1: {
    0: 1
    1: 1
  }
}[B1][B2]

export type Keys<U extends Union> = U extends unknown ? keyof U : never

export type GetScalarType<T, O> = O extends object ? {
  [P in keyof T]: P extends keyof O
    ? O[P]
    : never
} : never

type FieldPaths<
  T,
  U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
> = IsObject<T> extends True ? U : T

export type GetHavingFields<T> = {
  [K in keyof T]: Or<
    Or<Extends<'OR', K>, Extends<'AND', K>>,
    Extends<'NOT', K>
  > extends True
    ? // infer is only needed to not hit TS limit
      // based on the brilliant idea of Pierre-Antoine Mills
      // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
      T[K] extends infer TK
      ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
      : never
    : {} extends FieldPaths<T[K]>
    ? never
    : K
}[keyof T]

/**
 * Convert tuple to union
 */
type _TupleToUnion<T> = T extends (infer E)[] ? E : never
type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
export type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

/**
 * Like `Pick`, but additionally can also accept an array of keys
 */
export type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

/**
 * Exclude all keys with underscores
 */
export type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


export const ModelName = {
  Tenant: 'Tenant',
  Organization: 'Organization',
  Church: 'Church',
  Campus: 'Campus',
  Household: 'Household',
  Member: 'Member',
  MemberAccessRequest: 'MemberAccessRequest',
  StaffInvite: 'StaffInvite',
  PlatformUser: 'PlatformUser',
  PlatformUserRole: 'PlatformUserRole',
  SubscriptionPlan: 'SubscriptionPlan',
  SubscriptionPlanFeature: 'SubscriptionPlanFeature',
  TenantSubscription: 'TenantSubscription',
  ImportBatch: 'ImportBatch',
  ImportBatchItem: 'ImportBatchItem',
  MemberRegistration: 'MemberRegistration',
  MemberTag: 'MemberTag',
  MemberTagAssignment: 'MemberTagAssignment',
  MemberMilestone: 'MemberMilestone',
  Group: 'Group',
  OnboardingWorkflow: 'OnboardingWorkflow',
  OnboardingStep: 'OnboardingStep',
  MemberOnboarding: 'MemberOnboarding',
  MemberOnboardingTask: 'MemberOnboardingTask',
  GroupMember: 'GroupMember',
  VolunteerRole: 'VolunteerRole',
  VolunteerShift: 'VolunteerShift',
  VolunteerShiftAssignment: 'VolunteerShiftAssignment',
  VolunteerAvailability: 'VolunteerAvailability',
  Survey: 'Survey',
  SurveyQuestion: 'SurveyQuestion',
  SurveyResponse: 'SurveyResponse',
  VolunteerAssignment: 'VolunteerAssignment',
  Event: 'Event',
  EventSeries: 'EventSeries',
  EventRsvp: 'EventRsvp',
  EventBadge: 'EventBadge',
  EventRegistration: 'EventRegistration',
  EventAssignment: 'EventAssignment',
  EventMedia: 'EventMedia',
  EventTicketType: 'EventTicketType',
  EventTicketOrder: 'EventTicketOrder',
  Conversation: 'Conversation',
  ConversationMember: 'ConversationMember',
  Message: 'Message',
  MediaAsset: 'MediaAsset',
  NotificationPreference: 'NotificationPreference',
  InAppNotification: 'InAppNotification',
  DeviceToken: 'DeviceToken',
  Attendance: 'Attendance',
  MemberRelationship: 'MemberRelationship',
  Donation: 'Donation',
  Fund: 'Fund',
  Campaign: 'Campaign',
  PaymentIntent: 'PaymentIntent',
  DonationReceipt: 'DonationReceipt',
  TextToGiveNumber: 'TextToGiveNumber',
  TextToGiveMessage: 'TextToGiveMessage',
  Payout: 'Payout',
  PayoutTransaction: 'PayoutTransaction',
  Refund: 'Refund',
  Dispute: 'Dispute',
  DisputeEvidence: 'DisputeEvidence',
  CommunicationSchedule: 'CommunicationSchedule',
  CommunicationDripCampaign: 'CommunicationDripCampaign',
  CommunicationDripStep: 'CommunicationDripStep',
  CommunicationDripEnrollment: 'CommunicationDripEnrollment',
  CommunicationTemplate: 'CommunicationTemplate',
  CommunicationMessage: 'CommunicationMessage',
  CommunicationSuppression: 'CommunicationSuppression',
  AiInteraction: 'AiInteraction',
  FundraiserPage: 'FundraiserPage',
  Pledge: 'Pledge',
  RecurringDonation: 'RecurringDonation',
  ExpenseCategory: 'ExpenseCategory',
  Expense: 'Expense',
  Budget: 'Budget',
  BudgetItem: 'BudgetItem',
  AuditLog: 'AuditLog',
  User: 'User',
  StaffMembership: 'StaffMembership',
  Facility: 'Facility',
  FacilityBooking: 'FacilityBooking',
  CareRequest: 'CareRequest',
  CareNote: 'CareNote',
  Sermon: 'Sermon',
  ContentResource: 'ContentResource',
  TenantDomain: 'TenantDomain',
  TenantHealthCheck: 'TenantHealthCheck',
  TenantSecurityPolicy: 'TenantSecurityPolicy',
  SupportTicket: 'SupportTicket',
  SupportTicketMessage: 'SupportTicketMessage',
  WebhookEvent: 'WebhookEvent',
  LiveStreamChannel: 'LiveStreamChannel',
  LiveStreamSession: 'LiveStreamSession'
} as const

export type ModelName = (typeof ModelName)[keyof typeof ModelName]



export interface TypeMapCb<GlobalOmitOptions = {}> extends runtime.Types.Utils.Fn<{extArgs: runtime.Types.Extensions.InternalArgs }, runtime.Types.Utils.Record<string, any>> {
  returns: TypeMap<this['params']['extArgs'], GlobalOmitOptions>
}

export type TypeMap<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
  globalOmitOptions: {
    omit: GlobalOmitOptions
  }
  meta: {
    modelProps: "tenant" | "organization" | "church" | "campus" | "household" | "member" | "memberAccessRequest" | "staffInvite" | "platformUser" | "platformUserRole" | "subscriptionPlan" | "subscriptionPlanFeature" | "tenantSubscription" | "importBatch" | "importBatchItem" | "memberRegistration" | "memberTag" | "memberTagAssignment" | "memberMilestone" | "group" | "onboardingWorkflow" | "onboardingStep" | "memberOnboarding" | "memberOnboardingTask" | "groupMember" | "volunteerRole" | "volunteerShift" | "volunteerShiftAssignment" | "volunteerAvailability" | "survey" | "surveyQuestion" | "surveyResponse" | "volunteerAssignment" | "event" | "eventSeries" | "eventRsvp" | "eventBadge" | "eventRegistration" | "eventAssignment" | "eventMedia" | "eventTicketType" | "eventTicketOrder" | "conversation" | "conversationMember" | "message" | "mediaAsset" | "notificationPreference" | "inAppNotification" | "deviceToken" | "attendance" | "memberRelationship" | "donation" | "fund" | "campaign" | "paymentIntent" | "donationReceipt" | "textToGiveNumber" | "textToGiveMessage" | "payout" | "payoutTransaction" | "refund" | "dispute" | "disputeEvidence" | "communicationSchedule" | "communicationDripCampaign" | "communicationDripStep" | "communicationDripEnrollment" | "communicationTemplate" | "communicationMessage" | "communicationSuppression" | "aiInteraction" | "fundraiserPage" | "pledge" | "recurringDonation" | "expenseCategory" | "expense" | "budget" | "budgetItem" | "auditLog" | "user" | "staffMembership" | "facility" | "facilityBooking" | "careRequest" | "careNote" | "sermon" | "contentResource" | "tenantDomain" | "tenantHealthCheck" | "tenantSecurityPolicy" | "supportTicket" | "supportTicketMessage" | "webhookEvent" | "liveStreamChannel" | "liveStreamSession"
    txIsolationLevel: TransactionIsolationLevel
  }
  model: {
    Tenant: {
      payload: Prisma.$TenantPayload<ExtArgs>
      fields: Prisma.TenantFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TenantFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TenantFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>
        }
        findFirst: {
          args: Prisma.TenantFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TenantFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>
        }
        findMany: {
          args: Prisma.TenantFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>[]
        }
        create: {
          args: Prisma.TenantCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>
        }
        createMany: {
          args: Prisma.TenantCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TenantCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>[]
        }
        delete: {
          args: Prisma.TenantDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>
        }
        update: {
          args: Prisma.TenantUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>
        }
        deleteMany: {
          args: Prisma.TenantDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TenantUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TenantUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>[]
        }
        upsert: {
          args: Prisma.TenantUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>
        }
        aggregate: {
          args: Prisma.TenantAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTenant>
        }
        groupBy: {
          args: Prisma.TenantGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantGroupByOutputType>[]
        }
        count: {
          args: Prisma.TenantCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantCountAggregateOutputType> | number
        }
      }
    }
    Organization: {
      payload: Prisma.$OrganizationPayload<ExtArgs>
      fields: Prisma.OrganizationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OrganizationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OrganizationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>
        }
        findFirst: {
          args: Prisma.OrganizationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OrganizationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>
        }
        findMany: {
          args: Prisma.OrganizationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
        }
        create: {
          args: Prisma.OrganizationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>
        }
        createMany: {
          args: Prisma.OrganizationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.OrganizationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
        }
        delete: {
          args: Prisma.OrganizationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>
        }
        update: {
          args: Prisma.OrganizationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>
        }
        deleteMany: {
          args: Prisma.OrganizationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OrganizationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.OrganizationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
        }
        upsert: {
          args: Prisma.OrganizationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>
        }
        aggregate: {
          args: Prisma.OrganizationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOrganization>
        }
        groupBy: {
          args: Prisma.OrganizationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrganizationGroupByOutputType>[]
        }
        count: {
          args: Prisma.OrganizationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrganizationCountAggregateOutputType> | number
        }
      }
    }
    Church: {
      payload: Prisma.$ChurchPayload<ExtArgs>
      fields: Prisma.ChurchFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ChurchFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChurchPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ChurchFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChurchPayload>
        }
        findFirst: {
          args: Prisma.ChurchFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChurchPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ChurchFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChurchPayload>
        }
        findMany: {
          args: Prisma.ChurchFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChurchPayload>[]
        }
        create: {
          args: Prisma.ChurchCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChurchPayload>
        }
        createMany: {
          args: Prisma.ChurchCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ChurchCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChurchPayload>[]
        }
        delete: {
          args: Prisma.ChurchDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChurchPayload>
        }
        update: {
          args: Prisma.ChurchUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChurchPayload>
        }
        deleteMany: {
          args: Prisma.ChurchDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ChurchUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ChurchUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChurchPayload>[]
        }
        upsert: {
          args: Prisma.ChurchUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChurchPayload>
        }
        aggregate: {
          args: Prisma.ChurchAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateChurch>
        }
        groupBy: {
          args: Prisma.ChurchGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ChurchGroupByOutputType>[]
        }
        count: {
          args: Prisma.ChurchCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ChurchCountAggregateOutputType> | number
        }
      }
    }
    Campus: {
      payload: Prisma.$CampusPayload<ExtArgs>
      fields: Prisma.CampusFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CampusFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampusPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CampusFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampusPayload>
        }
        findFirst: {
          args: Prisma.CampusFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampusPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CampusFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampusPayload>
        }
        findMany: {
          args: Prisma.CampusFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampusPayload>[]
        }
        create: {
          args: Prisma.CampusCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampusPayload>
        }
        createMany: {
          args: Prisma.CampusCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CampusCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampusPayload>[]
        }
        delete: {
          args: Prisma.CampusDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampusPayload>
        }
        update: {
          args: Prisma.CampusUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampusPayload>
        }
        deleteMany: {
          args: Prisma.CampusDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CampusUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CampusUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampusPayload>[]
        }
        upsert: {
          args: Prisma.CampusUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampusPayload>
        }
        aggregate: {
          args: Prisma.CampusAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCampus>
        }
        groupBy: {
          args: Prisma.CampusGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CampusGroupByOutputType>[]
        }
        count: {
          args: Prisma.CampusCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CampusCountAggregateOutputType> | number
        }
      }
    }
    Household: {
      payload: Prisma.$HouseholdPayload<ExtArgs>
      fields: Prisma.HouseholdFieldRefs
      operations: {
        findUnique: {
          args: Prisma.HouseholdFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HouseholdPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.HouseholdFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HouseholdPayload>
        }
        findFirst: {
          args: Prisma.HouseholdFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HouseholdPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.HouseholdFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HouseholdPayload>
        }
        findMany: {
          args: Prisma.HouseholdFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HouseholdPayload>[]
        }
        create: {
          args: Prisma.HouseholdCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HouseholdPayload>
        }
        createMany: {
          args: Prisma.HouseholdCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.HouseholdCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HouseholdPayload>[]
        }
        delete: {
          args: Prisma.HouseholdDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HouseholdPayload>
        }
        update: {
          args: Prisma.HouseholdUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HouseholdPayload>
        }
        deleteMany: {
          args: Prisma.HouseholdDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.HouseholdUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.HouseholdUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HouseholdPayload>[]
        }
        upsert: {
          args: Prisma.HouseholdUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HouseholdPayload>
        }
        aggregate: {
          args: Prisma.HouseholdAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateHousehold>
        }
        groupBy: {
          args: Prisma.HouseholdGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.HouseholdGroupByOutputType>[]
        }
        count: {
          args: Prisma.HouseholdCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.HouseholdCountAggregateOutputType> | number
        }
      }
    }
    Member: {
      payload: Prisma.$MemberPayload<ExtArgs>
      fields: Prisma.MemberFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MemberFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MemberFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberPayload>
        }
        findFirst: {
          args: Prisma.MemberFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MemberFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberPayload>
        }
        findMany: {
          args: Prisma.MemberFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberPayload>[]
        }
        create: {
          args: Prisma.MemberCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberPayload>
        }
        createMany: {
          args: Prisma.MemberCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MemberCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberPayload>[]
        }
        delete: {
          args: Prisma.MemberDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberPayload>
        }
        update: {
          args: Prisma.MemberUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberPayload>
        }
        deleteMany: {
          args: Prisma.MemberDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MemberUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MemberUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberPayload>[]
        }
        upsert: {
          args: Prisma.MemberUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberPayload>
        }
        aggregate: {
          args: Prisma.MemberAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMember>
        }
        groupBy: {
          args: Prisma.MemberGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MemberGroupByOutputType>[]
        }
        count: {
          args: Prisma.MemberCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MemberCountAggregateOutputType> | number
        }
      }
    }
    MemberAccessRequest: {
      payload: Prisma.$MemberAccessRequestPayload<ExtArgs>
      fields: Prisma.MemberAccessRequestFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MemberAccessRequestFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberAccessRequestPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MemberAccessRequestFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberAccessRequestPayload>
        }
        findFirst: {
          args: Prisma.MemberAccessRequestFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberAccessRequestPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MemberAccessRequestFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberAccessRequestPayload>
        }
        findMany: {
          args: Prisma.MemberAccessRequestFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberAccessRequestPayload>[]
        }
        create: {
          args: Prisma.MemberAccessRequestCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberAccessRequestPayload>
        }
        createMany: {
          args: Prisma.MemberAccessRequestCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MemberAccessRequestCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberAccessRequestPayload>[]
        }
        delete: {
          args: Prisma.MemberAccessRequestDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberAccessRequestPayload>
        }
        update: {
          args: Prisma.MemberAccessRequestUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberAccessRequestPayload>
        }
        deleteMany: {
          args: Prisma.MemberAccessRequestDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MemberAccessRequestUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MemberAccessRequestUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberAccessRequestPayload>[]
        }
        upsert: {
          args: Prisma.MemberAccessRequestUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberAccessRequestPayload>
        }
        aggregate: {
          args: Prisma.MemberAccessRequestAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMemberAccessRequest>
        }
        groupBy: {
          args: Prisma.MemberAccessRequestGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MemberAccessRequestGroupByOutputType>[]
        }
        count: {
          args: Prisma.MemberAccessRequestCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MemberAccessRequestCountAggregateOutputType> | number
        }
      }
    }
    StaffInvite: {
      payload: Prisma.$StaffInvitePayload<ExtArgs>
      fields: Prisma.StaffInviteFieldRefs
      operations: {
        findUnique: {
          args: Prisma.StaffInviteFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffInvitePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.StaffInviteFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffInvitePayload>
        }
        findFirst: {
          args: Prisma.StaffInviteFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffInvitePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.StaffInviteFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffInvitePayload>
        }
        findMany: {
          args: Prisma.StaffInviteFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffInvitePayload>[]
        }
        create: {
          args: Prisma.StaffInviteCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffInvitePayload>
        }
        createMany: {
          args: Prisma.StaffInviteCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.StaffInviteCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffInvitePayload>[]
        }
        delete: {
          args: Prisma.StaffInviteDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffInvitePayload>
        }
        update: {
          args: Prisma.StaffInviteUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffInvitePayload>
        }
        deleteMany: {
          args: Prisma.StaffInviteDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.StaffInviteUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.StaffInviteUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffInvitePayload>[]
        }
        upsert: {
          args: Prisma.StaffInviteUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffInvitePayload>
        }
        aggregate: {
          args: Prisma.StaffInviteAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateStaffInvite>
        }
        groupBy: {
          args: Prisma.StaffInviteGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.StaffInviteGroupByOutputType>[]
        }
        count: {
          args: Prisma.StaffInviteCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.StaffInviteCountAggregateOutputType> | number
        }
      }
    }
    PlatformUser: {
      payload: Prisma.$PlatformUserPayload<ExtArgs>
      fields: Prisma.PlatformUserFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PlatformUserFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlatformUserPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PlatformUserFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlatformUserPayload>
        }
        findFirst: {
          args: Prisma.PlatformUserFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlatformUserPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PlatformUserFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlatformUserPayload>
        }
        findMany: {
          args: Prisma.PlatformUserFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlatformUserPayload>[]
        }
        create: {
          args: Prisma.PlatformUserCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlatformUserPayload>
        }
        createMany: {
          args: Prisma.PlatformUserCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PlatformUserCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlatformUserPayload>[]
        }
        delete: {
          args: Prisma.PlatformUserDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlatformUserPayload>
        }
        update: {
          args: Prisma.PlatformUserUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlatformUserPayload>
        }
        deleteMany: {
          args: Prisma.PlatformUserDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PlatformUserUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PlatformUserUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlatformUserPayload>[]
        }
        upsert: {
          args: Prisma.PlatformUserUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlatformUserPayload>
        }
        aggregate: {
          args: Prisma.PlatformUserAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePlatformUser>
        }
        groupBy: {
          args: Prisma.PlatformUserGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PlatformUserGroupByOutputType>[]
        }
        count: {
          args: Prisma.PlatformUserCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PlatformUserCountAggregateOutputType> | number
        }
      }
    }
    PlatformUserRole: {
      payload: Prisma.$PlatformUserRolePayload<ExtArgs>
      fields: Prisma.PlatformUserRoleFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PlatformUserRoleFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlatformUserRolePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PlatformUserRoleFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlatformUserRolePayload>
        }
        findFirst: {
          args: Prisma.PlatformUserRoleFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlatformUserRolePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PlatformUserRoleFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlatformUserRolePayload>
        }
        findMany: {
          args: Prisma.PlatformUserRoleFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlatformUserRolePayload>[]
        }
        create: {
          args: Prisma.PlatformUserRoleCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlatformUserRolePayload>
        }
        createMany: {
          args: Prisma.PlatformUserRoleCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PlatformUserRoleCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlatformUserRolePayload>[]
        }
        delete: {
          args: Prisma.PlatformUserRoleDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlatformUserRolePayload>
        }
        update: {
          args: Prisma.PlatformUserRoleUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlatformUserRolePayload>
        }
        deleteMany: {
          args: Prisma.PlatformUserRoleDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PlatformUserRoleUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PlatformUserRoleUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlatformUserRolePayload>[]
        }
        upsert: {
          args: Prisma.PlatformUserRoleUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlatformUserRolePayload>
        }
        aggregate: {
          args: Prisma.PlatformUserRoleAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePlatformUserRole>
        }
        groupBy: {
          args: Prisma.PlatformUserRoleGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PlatformUserRoleGroupByOutputType>[]
        }
        count: {
          args: Prisma.PlatformUserRoleCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PlatformUserRoleCountAggregateOutputType> | number
        }
      }
    }
    SubscriptionPlan: {
      payload: Prisma.$SubscriptionPlanPayload<ExtArgs>
      fields: Prisma.SubscriptionPlanFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SubscriptionPlanFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SubscriptionPlanFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
        }
        findFirst: {
          args: Prisma.SubscriptionPlanFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SubscriptionPlanFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
        }
        findMany: {
          args: Prisma.SubscriptionPlanFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>[]
        }
        create: {
          args: Prisma.SubscriptionPlanCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
        }
        createMany: {
          args: Prisma.SubscriptionPlanCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SubscriptionPlanCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>[]
        }
        delete: {
          args: Prisma.SubscriptionPlanDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
        }
        update: {
          args: Prisma.SubscriptionPlanUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
        }
        deleteMany: {
          args: Prisma.SubscriptionPlanDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SubscriptionPlanUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SubscriptionPlanUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>[]
        }
        upsert: {
          args: Prisma.SubscriptionPlanUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
        }
        aggregate: {
          args: Prisma.SubscriptionPlanAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSubscriptionPlan>
        }
        groupBy: {
          args: Prisma.SubscriptionPlanGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SubscriptionPlanGroupByOutputType>[]
        }
        count: {
          args: Prisma.SubscriptionPlanCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SubscriptionPlanCountAggregateOutputType> | number
        }
      }
    }
    SubscriptionPlanFeature: {
      payload: Prisma.$SubscriptionPlanFeaturePayload<ExtArgs>
      fields: Prisma.SubscriptionPlanFeatureFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SubscriptionPlanFeatureFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPlanFeaturePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SubscriptionPlanFeatureFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPlanFeaturePayload>
        }
        findFirst: {
          args: Prisma.SubscriptionPlanFeatureFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPlanFeaturePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SubscriptionPlanFeatureFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPlanFeaturePayload>
        }
        findMany: {
          args: Prisma.SubscriptionPlanFeatureFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPlanFeaturePayload>[]
        }
        create: {
          args: Prisma.SubscriptionPlanFeatureCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPlanFeaturePayload>
        }
        createMany: {
          args: Prisma.SubscriptionPlanFeatureCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SubscriptionPlanFeatureCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPlanFeaturePayload>[]
        }
        delete: {
          args: Prisma.SubscriptionPlanFeatureDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPlanFeaturePayload>
        }
        update: {
          args: Prisma.SubscriptionPlanFeatureUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPlanFeaturePayload>
        }
        deleteMany: {
          args: Prisma.SubscriptionPlanFeatureDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SubscriptionPlanFeatureUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SubscriptionPlanFeatureUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPlanFeaturePayload>[]
        }
        upsert: {
          args: Prisma.SubscriptionPlanFeatureUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPlanFeaturePayload>
        }
        aggregate: {
          args: Prisma.SubscriptionPlanFeatureAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSubscriptionPlanFeature>
        }
        groupBy: {
          args: Prisma.SubscriptionPlanFeatureGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SubscriptionPlanFeatureGroupByOutputType>[]
        }
        count: {
          args: Prisma.SubscriptionPlanFeatureCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SubscriptionPlanFeatureCountAggregateOutputType> | number
        }
      }
    }
    TenantSubscription: {
      payload: Prisma.$TenantSubscriptionPayload<ExtArgs>
      fields: Prisma.TenantSubscriptionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TenantSubscriptionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantSubscriptionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TenantSubscriptionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantSubscriptionPayload>
        }
        findFirst: {
          args: Prisma.TenantSubscriptionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantSubscriptionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TenantSubscriptionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantSubscriptionPayload>
        }
        findMany: {
          args: Prisma.TenantSubscriptionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantSubscriptionPayload>[]
        }
        create: {
          args: Prisma.TenantSubscriptionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantSubscriptionPayload>
        }
        createMany: {
          args: Prisma.TenantSubscriptionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TenantSubscriptionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantSubscriptionPayload>[]
        }
        delete: {
          args: Prisma.TenantSubscriptionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantSubscriptionPayload>
        }
        update: {
          args: Prisma.TenantSubscriptionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantSubscriptionPayload>
        }
        deleteMany: {
          args: Prisma.TenantSubscriptionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TenantSubscriptionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TenantSubscriptionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantSubscriptionPayload>[]
        }
        upsert: {
          args: Prisma.TenantSubscriptionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantSubscriptionPayload>
        }
        aggregate: {
          args: Prisma.TenantSubscriptionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTenantSubscription>
        }
        groupBy: {
          args: Prisma.TenantSubscriptionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantSubscriptionGroupByOutputType>[]
        }
        count: {
          args: Prisma.TenantSubscriptionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantSubscriptionCountAggregateOutputType> | number
        }
      }
    }
    ImportBatch: {
      payload: Prisma.$ImportBatchPayload<ExtArgs>
      fields: Prisma.ImportBatchFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ImportBatchFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImportBatchPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ImportBatchFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImportBatchPayload>
        }
        findFirst: {
          args: Prisma.ImportBatchFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImportBatchPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ImportBatchFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImportBatchPayload>
        }
        findMany: {
          args: Prisma.ImportBatchFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImportBatchPayload>[]
        }
        create: {
          args: Prisma.ImportBatchCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImportBatchPayload>
        }
        createMany: {
          args: Prisma.ImportBatchCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ImportBatchCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImportBatchPayload>[]
        }
        delete: {
          args: Prisma.ImportBatchDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImportBatchPayload>
        }
        update: {
          args: Prisma.ImportBatchUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImportBatchPayload>
        }
        deleteMany: {
          args: Prisma.ImportBatchDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ImportBatchUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ImportBatchUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImportBatchPayload>[]
        }
        upsert: {
          args: Prisma.ImportBatchUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImportBatchPayload>
        }
        aggregate: {
          args: Prisma.ImportBatchAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateImportBatch>
        }
        groupBy: {
          args: Prisma.ImportBatchGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ImportBatchGroupByOutputType>[]
        }
        count: {
          args: Prisma.ImportBatchCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ImportBatchCountAggregateOutputType> | number
        }
      }
    }
    ImportBatchItem: {
      payload: Prisma.$ImportBatchItemPayload<ExtArgs>
      fields: Prisma.ImportBatchItemFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ImportBatchItemFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImportBatchItemPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ImportBatchItemFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImportBatchItemPayload>
        }
        findFirst: {
          args: Prisma.ImportBatchItemFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImportBatchItemPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ImportBatchItemFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImportBatchItemPayload>
        }
        findMany: {
          args: Prisma.ImportBatchItemFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImportBatchItemPayload>[]
        }
        create: {
          args: Prisma.ImportBatchItemCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImportBatchItemPayload>
        }
        createMany: {
          args: Prisma.ImportBatchItemCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ImportBatchItemCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImportBatchItemPayload>[]
        }
        delete: {
          args: Prisma.ImportBatchItemDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImportBatchItemPayload>
        }
        update: {
          args: Prisma.ImportBatchItemUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImportBatchItemPayload>
        }
        deleteMany: {
          args: Prisma.ImportBatchItemDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ImportBatchItemUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ImportBatchItemUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImportBatchItemPayload>[]
        }
        upsert: {
          args: Prisma.ImportBatchItemUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImportBatchItemPayload>
        }
        aggregate: {
          args: Prisma.ImportBatchItemAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateImportBatchItem>
        }
        groupBy: {
          args: Prisma.ImportBatchItemGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ImportBatchItemGroupByOutputType>[]
        }
        count: {
          args: Prisma.ImportBatchItemCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ImportBatchItemCountAggregateOutputType> | number
        }
      }
    }
    MemberRegistration: {
      payload: Prisma.$MemberRegistrationPayload<ExtArgs>
      fields: Prisma.MemberRegistrationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MemberRegistrationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberRegistrationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MemberRegistrationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberRegistrationPayload>
        }
        findFirst: {
          args: Prisma.MemberRegistrationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberRegistrationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MemberRegistrationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberRegistrationPayload>
        }
        findMany: {
          args: Prisma.MemberRegistrationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberRegistrationPayload>[]
        }
        create: {
          args: Prisma.MemberRegistrationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberRegistrationPayload>
        }
        createMany: {
          args: Prisma.MemberRegistrationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MemberRegistrationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberRegistrationPayload>[]
        }
        delete: {
          args: Prisma.MemberRegistrationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberRegistrationPayload>
        }
        update: {
          args: Prisma.MemberRegistrationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberRegistrationPayload>
        }
        deleteMany: {
          args: Prisma.MemberRegistrationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MemberRegistrationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MemberRegistrationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberRegistrationPayload>[]
        }
        upsert: {
          args: Prisma.MemberRegistrationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberRegistrationPayload>
        }
        aggregate: {
          args: Prisma.MemberRegistrationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMemberRegistration>
        }
        groupBy: {
          args: Prisma.MemberRegistrationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MemberRegistrationGroupByOutputType>[]
        }
        count: {
          args: Prisma.MemberRegistrationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MemberRegistrationCountAggregateOutputType> | number
        }
      }
    }
    MemberTag: {
      payload: Prisma.$MemberTagPayload<ExtArgs>
      fields: Prisma.MemberTagFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MemberTagFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberTagPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MemberTagFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberTagPayload>
        }
        findFirst: {
          args: Prisma.MemberTagFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberTagPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MemberTagFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberTagPayload>
        }
        findMany: {
          args: Prisma.MemberTagFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberTagPayload>[]
        }
        create: {
          args: Prisma.MemberTagCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberTagPayload>
        }
        createMany: {
          args: Prisma.MemberTagCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MemberTagCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberTagPayload>[]
        }
        delete: {
          args: Prisma.MemberTagDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberTagPayload>
        }
        update: {
          args: Prisma.MemberTagUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberTagPayload>
        }
        deleteMany: {
          args: Prisma.MemberTagDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MemberTagUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MemberTagUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberTagPayload>[]
        }
        upsert: {
          args: Prisma.MemberTagUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberTagPayload>
        }
        aggregate: {
          args: Prisma.MemberTagAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMemberTag>
        }
        groupBy: {
          args: Prisma.MemberTagGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MemberTagGroupByOutputType>[]
        }
        count: {
          args: Prisma.MemberTagCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MemberTagCountAggregateOutputType> | number
        }
      }
    }
    MemberTagAssignment: {
      payload: Prisma.$MemberTagAssignmentPayload<ExtArgs>
      fields: Prisma.MemberTagAssignmentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MemberTagAssignmentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberTagAssignmentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MemberTagAssignmentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberTagAssignmentPayload>
        }
        findFirst: {
          args: Prisma.MemberTagAssignmentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberTagAssignmentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MemberTagAssignmentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberTagAssignmentPayload>
        }
        findMany: {
          args: Prisma.MemberTagAssignmentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberTagAssignmentPayload>[]
        }
        create: {
          args: Prisma.MemberTagAssignmentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberTagAssignmentPayload>
        }
        createMany: {
          args: Prisma.MemberTagAssignmentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MemberTagAssignmentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberTagAssignmentPayload>[]
        }
        delete: {
          args: Prisma.MemberTagAssignmentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberTagAssignmentPayload>
        }
        update: {
          args: Prisma.MemberTagAssignmentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberTagAssignmentPayload>
        }
        deleteMany: {
          args: Prisma.MemberTagAssignmentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MemberTagAssignmentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MemberTagAssignmentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberTagAssignmentPayload>[]
        }
        upsert: {
          args: Prisma.MemberTagAssignmentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberTagAssignmentPayload>
        }
        aggregate: {
          args: Prisma.MemberTagAssignmentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMemberTagAssignment>
        }
        groupBy: {
          args: Prisma.MemberTagAssignmentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MemberTagAssignmentGroupByOutputType>[]
        }
        count: {
          args: Prisma.MemberTagAssignmentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MemberTagAssignmentCountAggregateOutputType> | number
        }
      }
    }
    MemberMilestone: {
      payload: Prisma.$MemberMilestonePayload<ExtArgs>
      fields: Prisma.MemberMilestoneFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MemberMilestoneFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberMilestonePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MemberMilestoneFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberMilestonePayload>
        }
        findFirst: {
          args: Prisma.MemberMilestoneFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberMilestonePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MemberMilestoneFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberMilestonePayload>
        }
        findMany: {
          args: Prisma.MemberMilestoneFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberMilestonePayload>[]
        }
        create: {
          args: Prisma.MemberMilestoneCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberMilestonePayload>
        }
        createMany: {
          args: Prisma.MemberMilestoneCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MemberMilestoneCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberMilestonePayload>[]
        }
        delete: {
          args: Prisma.MemberMilestoneDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberMilestonePayload>
        }
        update: {
          args: Prisma.MemberMilestoneUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberMilestonePayload>
        }
        deleteMany: {
          args: Prisma.MemberMilestoneDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MemberMilestoneUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MemberMilestoneUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberMilestonePayload>[]
        }
        upsert: {
          args: Prisma.MemberMilestoneUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberMilestonePayload>
        }
        aggregate: {
          args: Prisma.MemberMilestoneAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMemberMilestone>
        }
        groupBy: {
          args: Prisma.MemberMilestoneGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MemberMilestoneGroupByOutputType>[]
        }
        count: {
          args: Prisma.MemberMilestoneCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MemberMilestoneCountAggregateOutputType> | number
        }
      }
    }
    Group: {
      payload: Prisma.$GroupPayload<ExtArgs>
      fields: Prisma.GroupFieldRefs
      operations: {
        findUnique: {
          args: Prisma.GroupFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.GroupFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupPayload>
        }
        findFirst: {
          args: Prisma.GroupFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.GroupFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupPayload>
        }
        findMany: {
          args: Prisma.GroupFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupPayload>[]
        }
        create: {
          args: Prisma.GroupCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupPayload>
        }
        createMany: {
          args: Prisma.GroupCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.GroupCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupPayload>[]
        }
        delete: {
          args: Prisma.GroupDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupPayload>
        }
        update: {
          args: Prisma.GroupUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupPayload>
        }
        deleteMany: {
          args: Prisma.GroupDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.GroupUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.GroupUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupPayload>[]
        }
        upsert: {
          args: Prisma.GroupUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupPayload>
        }
        aggregate: {
          args: Prisma.GroupAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateGroup>
        }
        groupBy: {
          args: Prisma.GroupGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GroupGroupByOutputType>[]
        }
        count: {
          args: Prisma.GroupCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GroupCountAggregateOutputType> | number
        }
      }
    }
    OnboardingWorkflow: {
      payload: Prisma.$OnboardingWorkflowPayload<ExtArgs>
      fields: Prisma.OnboardingWorkflowFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OnboardingWorkflowFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingWorkflowPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OnboardingWorkflowFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingWorkflowPayload>
        }
        findFirst: {
          args: Prisma.OnboardingWorkflowFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingWorkflowPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OnboardingWorkflowFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingWorkflowPayload>
        }
        findMany: {
          args: Prisma.OnboardingWorkflowFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingWorkflowPayload>[]
        }
        create: {
          args: Prisma.OnboardingWorkflowCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingWorkflowPayload>
        }
        createMany: {
          args: Prisma.OnboardingWorkflowCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.OnboardingWorkflowCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingWorkflowPayload>[]
        }
        delete: {
          args: Prisma.OnboardingWorkflowDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingWorkflowPayload>
        }
        update: {
          args: Prisma.OnboardingWorkflowUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingWorkflowPayload>
        }
        deleteMany: {
          args: Prisma.OnboardingWorkflowDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OnboardingWorkflowUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.OnboardingWorkflowUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingWorkflowPayload>[]
        }
        upsert: {
          args: Prisma.OnboardingWorkflowUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingWorkflowPayload>
        }
        aggregate: {
          args: Prisma.OnboardingWorkflowAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOnboardingWorkflow>
        }
        groupBy: {
          args: Prisma.OnboardingWorkflowGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OnboardingWorkflowGroupByOutputType>[]
        }
        count: {
          args: Prisma.OnboardingWorkflowCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OnboardingWorkflowCountAggregateOutputType> | number
        }
      }
    }
    OnboardingStep: {
      payload: Prisma.$OnboardingStepPayload<ExtArgs>
      fields: Prisma.OnboardingStepFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OnboardingStepFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingStepPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OnboardingStepFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingStepPayload>
        }
        findFirst: {
          args: Prisma.OnboardingStepFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingStepPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OnboardingStepFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingStepPayload>
        }
        findMany: {
          args: Prisma.OnboardingStepFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingStepPayload>[]
        }
        create: {
          args: Prisma.OnboardingStepCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingStepPayload>
        }
        createMany: {
          args: Prisma.OnboardingStepCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.OnboardingStepCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingStepPayload>[]
        }
        delete: {
          args: Prisma.OnboardingStepDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingStepPayload>
        }
        update: {
          args: Prisma.OnboardingStepUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingStepPayload>
        }
        deleteMany: {
          args: Prisma.OnboardingStepDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OnboardingStepUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.OnboardingStepUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingStepPayload>[]
        }
        upsert: {
          args: Prisma.OnboardingStepUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingStepPayload>
        }
        aggregate: {
          args: Prisma.OnboardingStepAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOnboardingStep>
        }
        groupBy: {
          args: Prisma.OnboardingStepGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OnboardingStepGroupByOutputType>[]
        }
        count: {
          args: Prisma.OnboardingStepCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OnboardingStepCountAggregateOutputType> | number
        }
      }
    }
    MemberOnboarding: {
      payload: Prisma.$MemberOnboardingPayload<ExtArgs>
      fields: Prisma.MemberOnboardingFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MemberOnboardingFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberOnboardingPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MemberOnboardingFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberOnboardingPayload>
        }
        findFirst: {
          args: Prisma.MemberOnboardingFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberOnboardingPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MemberOnboardingFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberOnboardingPayload>
        }
        findMany: {
          args: Prisma.MemberOnboardingFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberOnboardingPayload>[]
        }
        create: {
          args: Prisma.MemberOnboardingCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberOnboardingPayload>
        }
        createMany: {
          args: Prisma.MemberOnboardingCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MemberOnboardingCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberOnboardingPayload>[]
        }
        delete: {
          args: Prisma.MemberOnboardingDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberOnboardingPayload>
        }
        update: {
          args: Prisma.MemberOnboardingUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberOnboardingPayload>
        }
        deleteMany: {
          args: Prisma.MemberOnboardingDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MemberOnboardingUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MemberOnboardingUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberOnboardingPayload>[]
        }
        upsert: {
          args: Prisma.MemberOnboardingUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberOnboardingPayload>
        }
        aggregate: {
          args: Prisma.MemberOnboardingAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMemberOnboarding>
        }
        groupBy: {
          args: Prisma.MemberOnboardingGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MemberOnboardingGroupByOutputType>[]
        }
        count: {
          args: Prisma.MemberOnboardingCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MemberOnboardingCountAggregateOutputType> | number
        }
      }
    }
    MemberOnboardingTask: {
      payload: Prisma.$MemberOnboardingTaskPayload<ExtArgs>
      fields: Prisma.MemberOnboardingTaskFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MemberOnboardingTaskFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberOnboardingTaskPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MemberOnboardingTaskFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberOnboardingTaskPayload>
        }
        findFirst: {
          args: Prisma.MemberOnboardingTaskFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberOnboardingTaskPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MemberOnboardingTaskFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberOnboardingTaskPayload>
        }
        findMany: {
          args: Prisma.MemberOnboardingTaskFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberOnboardingTaskPayload>[]
        }
        create: {
          args: Prisma.MemberOnboardingTaskCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberOnboardingTaskPayload>
        }
        createMany: {
          args: Prisma.MemberOnboardingTaskCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MemberOnboardingTaskCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberOnboardingTaskPayload>[]
        }
        delete: {
          args: Prisma.MemberOnboardingTaskDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberOnboardingTaskPayload>
        }
        update: {
          args: Prisma.MemberOnboardingTaskUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberOnboardingTaskPayload>
        }
        deleteMany: {
          args: Prisma.MemberOnboardingTaskDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MemberOnboardingTaskUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MemberOnboardingTaskUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberOnboardingTaskPayload>[]
        }
        upsert: {
          args: Prisma.MemberOnboardingTaskUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberOnboardingTaskPayload>
        }
        aggregate: {
          args: Prisma.MemberOnboardingTaskAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMemberOnboardingTask>
        }
        groupBy: {
          args: Prisma.MemberOnboardingTaskGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MemberOnboardingTaskGroupByOutputType>[]
        }
        count: {
          args: Prisma.MemberOnboardingTaskCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MemberOnboardingTaskCountAggregateOutputType> | number
        }
      }
    }
    GroupMember: {
      payload: Prisma.$GroupMemberPayload<ExtArgs>
      fields: Prisma.GroupMemberFieldRefs
      operations: {
        findUnique: {
          args: Prisma.GroupMemberFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupMemberPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.GroupMemberFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupMemberPayload>
        }
        findFirst: {
          args: Prisma.GroupMemberFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupMemberPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.GroupMemberFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupMemberPayload>
        }
        findMany: {
          args: Prisma.GroupMemberFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupMemberPayload>[]
        }
        create: {
          args: Prisma.GroupMemberCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupMemberPayload>
        }
        createMany: {
          args: Prisma.GroupMemberCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.GroupMemberCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupMemberPayload>[]
        }
        delete: {
          args: Prisma.GroupMemberDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupMemberPayload>
        }
        update: {
          args: Prisma.GroupMemberUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupMemberPayload>
        }
        deleteMany: {
          args: Prisma.GroupMemberDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.GroupMemberUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.GroupMemberUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupMemberPayload>[]
        }
        upsert: {
          args: Prisma.GroupMemberUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupMemberPayload>
        }
        aggregate: {
          args: Prisma.GroupMemberAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateGroupMember>
        }
        groupBy: {
          args: Prisma.GroupMemberGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GroupMemberGroupByOutputType>[]
        }
        count: {
          args: Prisma.GroupMemberCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GroupMemberCountAggregateOutputType> | number
        }
      }
    }
    VolunteerRole: {
      payload: Prisma.$VolunteerRolePayload<ExtArgs>
      fields: Prisma.VolunteerRoleFieldRefs
      operations: {
        findUnique: {
          args: Prisma.VolunteerRoleFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerRolePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.VolunteerRoleFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerRolePayload>
        }
        findFirst: {
          args: Prisma.VolunteerRoleFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerRolePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.VolunteerRoleFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerRolePayload>
        }
        findMany: {
          args: Prisma.VolunteerRoleFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerRolePayload>[]
        }
        create: {
          args: Prisma.VolunteerRoleCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerRolePayload>
        }
        createMany: {
          args: Prisma.VolunteerRoleCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.VolunteerRoleCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerRolePayload>[]
        }
        delete: {
          args: Prisma.VolunteerRoleDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerRolePayload>
        }
        update: {
          args: Prisma.VolunteerRoleUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerRolePayload>
        }
        deleteMany: {
          args: Prisma.VolunteerRoleDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.VolunteerRoleUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.VolunteerRoleUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerRolePayload>[]
        }
        upsert: {
          args: Prisma.VolunteerRoleUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerRolePayload>
        }
        aggregate: {
          args: Prisma.VolunteerRoleAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVolunteerRole>
        }
        groupBy: {
          args: Prisma.VolunteerRoleGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VolunteerRoleGroupByOutputType>[]
        }
        count: {
          args: Prisma.VolunteerRoleCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VolunteerRoleCountAggregateOutputType> | number
        }
      }
    }
    VolunteerShift: {
      payload: Prisma.$VolunteerShiftPayload<ExtArgs>
      fields: Prisma.VolunteerShiftFieldRefs
      operations: {
        findUnique: {
          args: Prisma.VolunteerShiftFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerShiftPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.VolunteerShiftFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerShiftPayload>
        }
        findFirst: {
          args: Prisma.VolunteerShiftFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerShiftPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.VolunteerShiftFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerShiftPayload>
        }
        findMany: {
          args: Prisma.VolunteerShiftFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerShiftPayload>[]
        }
        create: {
          args: Prisma.VolunteerShiftCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerShiftPayload>
        }
        createMany: {
          args: Prisma.VolunteerShiftCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.VolunteerShiftCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerShiftPayload>[]
        }
        delete: {
          args: Prisma.VolunteerShiftDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerShiftPayload>
        }
        update: {
          args: Prisma.VolunteerShiftUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerShiftPayload>
        }
        deleteMany: {
          args: Prisma.VolunteerShiftDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.VolunteerShiftUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.VolunteerShiftUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerShiftPayload>[]
        }
        upsert: {
          args: Prisma.VolunteerShiftUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerShiftPayload>
        }
        aggregate: {
          args: Prisma.VolunteerShiftAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVolunteerShift>
        }
        groupBy: {
          args: Prisma.VolunteerShiftGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VolunteerShiftGroupByOutputType>[]
        }
        count: {
          args: Prisma.VolunteerShiftCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VolunteerShiftCountAggregateOutputType> | number
        }
      }
    }
    VolunteerShiftAssignment: {
      payload: Prisma.$VolunteerShiftAssignmentPayload<ExtArgs>
      fields: Prisma.VolunteerShiftAssignmentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.VolunteerShiftAssignmentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerShiftAssignmentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.VolunteerShiftAssignmentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerShiftAssignmentPayload>
        }
        findFirst: {
          args: Prisma.VolunteerShiftAssignmentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerShiftAssignmentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.VolunteerShiftAssignmentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerShiftAssignmentPayload>
        }
        findMany: {
          args: Prisma.VolunteerShiftAssignmentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerShiftAssignmentPayload>[]
        }
        create: {
          args: Prisma.VolunteerShiftAssignmentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerShiftAssignmentPayload>
        }
        createMany: {
          args: Prisma.VolunteerShiftAssignmentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.VolunteerShiftAssignmentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerShiftAssignmentPayload>[]
        }
        delete: {
          args: Prisma.VolunteerShiftAssignmentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerShiftAssignmentPayload>
        }
        update: {
          args: Prisma.VolunteerShiftAssignmentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerShiftAssignmentPayload>
        }
        deleteMany: {
          args: Prisma.VolunteerShiftAssignmentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.VolunteerShiftAssignmentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.VolunteerShiftAssignmentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerShiftAssignmentPayload>[]
        }
        upsert: {
          args: Prisma.VolunteerShiftAssignmentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerShiftAssignmentPayload>
        }
        aggregate: {
          args: Prisma.VolunteerShiftAssignmentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVolunteerShiftAssignment>
        }
        groupBy: {
          args: Prisma.VolunteerShiftAssignmentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VolunteerShiftAssignmentGroupByOutputType>[]
        }
        count: {
          args: Prisma.VolunteerShiftAssignmentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VolunteerShiftAssignmentCountAggregateOutputType> | number
        }
      }
    }
    VolunteerAvailability: {
      payload: Prisma.$VolunteerAvailabilityPayload<ExtArgs>
      fields: Prisma.VolunteerAvailabilityFieldRefs
      operations: {
        findUnique: {
          args: Prisma.VolunteerAvailabilityFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerAvailabilityPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.VolunteerAvailabilityFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerAvailabilityPayload>
        }
        findFirst: {
          args: Prisma.VolunteerAvailabilityFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerAvailabilityPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.VolunteerAvailabilityFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerAvailabilityPayload>
        }
        findMany: {
          args: Prisma.VolunteerAvailabilityFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerAvailabilityPayload>[]
        }
        create: {
          args: Prisma.VolunteerAvailabilityCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerAvailabilityPayload>
        }
        createMany: {
          args: Prisma.VolunteerAvailabilityCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.VolunteerAvailabilityCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerAvailabilityPayload>[]
        }
        delete: {
          args: Prisma.VolunteerAvailabilityDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerAvailabilityPayload>
        }
        update: {
          args: Prisma.VolunteerAvailabilityUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerAvailabilityPayload>
        }
        deleteMany: {
          args: Prisma.VolunteerAvailabilityDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.VolunteerAvailabilityUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.VolunteerAvailabilityUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerAvailabilityPayload>[]
        }
        upsert: {
          args: Prisma.VolunteerAvailabilityUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerAvailabilityPayload>
        }
        aggregate: {
          args: Prisma.VolunteerAvailabilityAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVolunteerAvailability>
        }
        groupBy: {
          args: Prisma.VolunteerAvailabilityGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VolunteerAvailabilityGroupByOutputType>[]
        }
        count: {
          args: Prisma.VolunteerAvailabilityCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VolunteerAvailabilityCountAggregateOutputType> | number
        }
      }
    }
    Survey: {
      payload: Prisma.$SurveyPayload<ExtArgs>
      fields: Prisma.SurveyFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SurveyFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SurveyFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyPayload>
        }
        findFirst: {
          args: Prisma.SurveyFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SurveyFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyPayload>
        }
        findMany: {
          args: Prisma.SurveyFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyPayload>[]
        }
        create: {
          args: Prisma.SurveyCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyPayload>
        }
        createMany: {
          args: Prisma.SurveyCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SurveyCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyPayload>[]
        }
        delete: {
          args: Prisma.SurveyDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyPayload>
        }
        update: {
          args: Prisma.SurveyUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyPayload>
        }
        deleteMany: {
          args: Prisma.SurveyDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SurveyUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SurveyUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyPayload>[]
        }
        upsert: {
          args: Prisma.SurveyUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyPayload>
        }
        aggregate: {
          args: Prisma.SurveyAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSurvey>
        }
        groupBy: {
          args: Prisma.SurveyGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SurveyGroupByOutputType>[]
        }
        count: {
          args: Prisma.SurveyCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SurveyCountAggregateOutputType> | number
        }
      }
    }
    SurveyQuestion: {
      payload: Prisma.$SurveyQuestionPayload<ExtArgs>
      fields: Prisma.SurveyQuestionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SurveyQuestionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyQuestionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SurveyQuestionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyQuestionPayload>
        }
        findFirst: {
          args: Prisma.SurveyQuestionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyQuestionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SurveyQuestionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyQuestionPayload>
        }
        findMany: {
          args: Prisma.SurveyQuestionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyQuestionPayload>[]
        }
        create: {
          args: Prisma.SurveyQuestionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyQuestionPayload>
        }
        createMany: {
          args: Prisma.SurveyQuestionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SurveyQuestionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyQuestionPayload>[]
        }
        delete: {
          args: Prisma.SurveyQuestionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyQuestionPayload>
        }
        update: {
          args: Prisma.SurveyQuestionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyQuestionPayload>
        }
        deleteMany: {
          args: Prisma.SurveyQuestionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SurveyQuestionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SurveyQuestionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyQuestionPayload>[]
        }
        upsert: {
          args: Prisma.SurveyQuestionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyQuestionPayload>
        }
        aggregate: {
          args: Prisma.SurveyQuestionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSurveyQuestion>
        }
        groupBy: {
          args: Prisma.SurveyQuestionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SurveyQuestionGroupByOutputType>[]
        }
        count: {
          args: Prisma.SurveyQuestionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SurveyQuestionCountAggregateOutputType> | number
        }
      }
    }
    SurveyResponse: {
      payload: Prisma.$SurveyResponsePayload<ExtArgs>
      fields: Prisma.SurveyResponseFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SurveyResponseFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyResponsePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SurveyResponseFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyResponsePayload>
        }
        findFirst: {
          args: Prisma.SurveyResponseFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyResponsePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SurveyResponseFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyResponsePayload>
        }
        findMany: {
          args: Prisma.SurveyResponseFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyResponsePayload>[]
        }
        create: {
          args: Prisma.SurveyResponseCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyResponsePayload>
        }
        createMany: {
          args: Prisma.SurveyResponseCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SurveyResponseCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyResponsePayload>[]
        }
        delete: {
          args: Prisma.SurveyResponseDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyResponsePayload>
        }
        update: {
          args: Prisma.SurveyResponseUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyResponsePayload>
        }
        deleteMany: {
          args: Prisma.SurveyResponseDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SurveyResponseUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SurveyResponseUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyResponsePayload>[]
        }
        upsert: {
          args: Prisma.SurveyResponseUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyResponsePayload>
        }
        aggregate: {
          args: Prisma.SurveyResponseAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSurveyResponse>
        }
        groupBy: {
          args: Prisma.SurveyResponseGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SurveyResponseGroupByOutputType>[]
        }
        count: {
          args: Prisma.SurveyResponseCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SurveyResponseCountAggregateOutputType> | number
        }
      }
    }
    VolunteerAssignment: {
      payload: Prisma.$VolunteerAssignmentPayload<ExtArgs>
      fields: Prisma.VolunteerAssignmentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.VolunteerAssignmentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerAssignmentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.VolunteerAssignmentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerAssignmentPayload>
        }
        findFirst: {
          args: Prisma.VolunteerAssignmentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerAssignmentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.VolunteerAssignmentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerAssignmentPayload>
        }
        findMany: {
          args: Prisma.VolunteerAssignmentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerAssignmentPayload>[]
        }
        create: {
          args: Prisma.VolunteerAssignmentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerAssignmentPayload>
        }
        createMany: {
          args: Prisma.VolunteerAssignmentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.VolunteerAssignmentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerAssignmentPayload>[]
        }
        delete: {
          args: Prisma.VolunteerAssignmentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerAssignmentPayload>
        }
        update: {
          args: Prisma.VolunteerAssignmentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerAssignmentPayload>
        }
        deleteMany: {
          args: Prisma.VolunteerAssignmentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.VolunteerAssignmentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.VolunteerAssignmentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerAssignmentPayload>[]
        }
        upsert: {
          args: Prisma.VolunteerAssignmentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerAssignmentPayload>
        }
        aggregate: {
          args: Prisma.VolunteerAssignmentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVolunteerAssignment>
        }
        groupBy: {
          args: Prisma.VolunteerAssignmentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VolunteerAssignmentGroupByOutputType>[]
        }
        count: {
          args: Prisma.VolunteerAssignmentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VolunteerAssignmentCountAggregateOutputType> | number
        }
      }
    }
    Event: {
      payload: Prisma.$EventPayload<ExtArgs>
      fields: Prisma.EventFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EventFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EventFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>
        }
        findFirst: {
          args: Prisma.EventFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EventFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>
        }
        findMany: {
          args: Prisma.EventFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>[]
        }
        create: {
          args: Prisma.EventCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>
        }
        createMany: {
          args: Prisma.EventCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EventCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>[]
        }
        delete: {
          args: Prisma.EventDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>
        }
        update: {
          args: Prisma.EventUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>
        }
        deleteMany: {
          args: Prisma.EventDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EventUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EventUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>[]
        }
        upsert: {
          args: Prisma.EventUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>
        }
        aggregate: {
          args: Prisma.EventAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEvent>
        }
        groupBy: {
          args: Prisma.EventGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventGroupByOutputType>[]
        }
        count: {
          args: Prisma.EventCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventCountAggregateOutputType> | number
        }
      }
    }
    EventSeries: {
      payload: Prisma.$EventSeriesPayload<ExtArgs>
      fields: Prisma.EventSeriesFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EventSeriesFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSeriesPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EventSeriesFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSeriesPayload>
        }
        findFirst: {
          args: Prisma.EventSeriesFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSeriesPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EventSeriesFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSeriesPayload>
        }
        findMany: {
          args: Prisma.EventSeriesFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSeriesPayload>[]
        }
        create: {
          args: Prisma.EventSeriesCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSeriesPayload>
        }
        createMany: {
          args: Prisma.EventSeriesCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EventSeriesCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSeriesPayload>[]
        }
        delete: {
          args: Prisma.EventSeriesDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSeriesPayload>
        }
        update: {
          args: Prisma.EventSeriesUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSeriesPayload>
        }
        deleteMany: {
          args: Prisma.EventSeriesDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EventSeriesUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EventSeriesUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSeriesPayload>[]
        }
        upsert: {
          args: Prisma.EventSeriesUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSeriesPayload>
        }
        aggregate: {
          args: Prisma.EventSeriesAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEventSeries>
        }
        groupBy: {
          args: Prisma.EventSeriesGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventSeriesGroupByOutputType>[]
        }
        count: {
          args: Prisma.EventSeriesCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventSeriesCountAggregateOutputType> | number
        }
      }
    }
    EventRsvp: {
      payload: Prisma.$EventRsvpPayload<ExtArgs>
      fields: Prisma.EventRsvpFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EventRsvpFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRsvpPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EventRsvpFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRsvpPayload>
        }
        findFirst: {
          args: Prisma.EventRsvpFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRsvpPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EventRsvpFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRsvpPayload>
        }
        findMany: {
          args: Prisma.EventRsvpFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRsvpPayload>[]
        }
        create: {
          args: Prisma.EventRsvpCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRsvpPayload>
        }
        createMany: {
          args: Prisma.EventRsvpCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EventRsvpCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRsvpPayload>[]
        }
        delete: {
          args: Prisma.EventRsvpDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRsvpPayload>
        }
        update: {
          args: Prisma.EventRsvpUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRsvpPayload>
        }
        deleteMany: {
          args: Prisma.EventRsvpDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EventRsvpUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EventRsvpUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRsvpPayload>[]
        }
        upsert: {
          args: Prisma.EventRsvpUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRsvpPayload>
        }
        aggregate: {
          args: Prisma.EventRsvpAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEventRsvp>
        }
        groupBy: {
          args: Prisma.EventRsvpGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventRsvpGroupByOutputType>[]
        }
        count: {
          args: Prisma.EventRsvpCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventRsvpCountAggregateOutputType> | number
        }
      }
    }
    EventBadge: {
      payload: Prisma.$EventBadgePayload<ExtArgs>
      fields: Prisma.EventBadgeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EventBadgeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventBadgePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EventBadgeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventBadgePayload>
        }
        findFirst: {
          args: Prisma.EventBadgeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventBadgePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EventBadgeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventBadgePayload>
        }
        findMany: {
          args: Prisma.EventBadgeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventBadgePayload>[]
        }
        create: {
          args: Prisma.EventBadgeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventBadgePayload>
        }
        createMany: {
          args: Prisma.EventBadgeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EventBadgeCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventBadgePayload>[]
        }
        delete: {
          args: Prisma.EventBadgeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventBadgePayload>
        }
        update: {
          args: Prisma.EventBadgeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventBadgePayload>
        }
        deleteMany: {
          args: Prisma.EventBadgeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EventBadgeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EventBadgeUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventBadgePayload>[]
        }
        upsert: {
          args: Prisma.EventBadgeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventBadgePayload>
        }
        aggregate: {
          args: Prisma.EventBadgeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEventBadge>
        }
        groupBy: {
          args: Prisma.EventBadgeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventBadgeGroupByOutputType>[]
        }
        count: {
          args: Prisma.EventBadgeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventBadgeCountAggregateOutputType> | number
        }
      }
    }
    EventRegistration: {
      payload: Prisma.$EventRegistrationPayload<ExtArgs>
      fields: Prisma.EventRegistrationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EventRegistrationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EventRegistrationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationPayload>
        }
        findFirst: {
          args: Prisma.EventRegistrationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EventRegistrationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationPayload>
        }
        findMany: {
          args: Prisma.EventRegistrationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationPayload>[]
        }
        create: {
          args: Prisma.EventRegistrationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationPayload>
        }
        createMany: {
          args: Prisma.EventRegistrationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EventRegistrationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationPayload>[]
        }
        delete: {
          args: Prisma.EventRegistrationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationPayload>
        }
        update: {
          args: Prisma.EventRegistrationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationPayload>
        }
        deleteMany: {
          args: Prisma.EventRegistrationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EventRegistrationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EventRegistrationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationPayload>[]
        }
        upsert: {
          args: Prisma.EventRegistrationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationPayload>
        }
        aggregate: {
          args: Prisma.EventRegistrationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEventRegistration>
        }
        groupBy: {
          args: Prisma.EventRegistrationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventRegistrationGroupByOutputType>[]
        }
        count: {
          args: Prisma.EventRegistrationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventRegistrationCountAggregateOutputType> | number
        }
      }
    }
    EventAssignment: {
      payload: Prisma.$EventAssignmentPayload<ExtArgs>
      fields: Prisma.EventAssignmentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EventAssignmentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAssignmentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EventAssignmentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAssignmentPayload>
        }
        findFirst: {
          args: Prisma.EventAssignmentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAssignmentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EventAssignmentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAssignmentPayload>
        }
        findMany: {
          args: Prisma.EventAssignmentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAssignmentPayload>[]
        }
        create: {
          args: Prisma.EventAssignmentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAssignmentPayload>
        }
        createMany: {
          args: Prisma.EventAssignmentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EventAssignmentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAssignmentPayload>[]
        }
        delete: {
          args: Prisma.EventAssignmentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAssignmentPayload>
        }
        update: {
          args: Prisma.EventAssignmentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAssignmentPayload>
        }
        deleteMany: {
          args: Prisma.EventAssignmentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EventAssignmentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EventAssignmentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAssignmentPayload>[]
        }
        upsert: {
          args: Prisma.EventAssignmentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAssignmentPayload>
        }
        aggregate: {
          args: Prisma.EventAssignmentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEventAssignment>
        }
        groupBy: {
          args: Prisma.EventAssignmentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventAssignmentGroupByOutputType>[]
        }
        count: {
          args: Prisma.EventAssignmentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventAssignmentCountAggregateOutputType> | number
        }
      }
    }
    EventMedia: {
      payload: Prisma.$EventMediaPayload<ExtArgs>
      fields: Prisma.EventMediaFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EventMediaFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventMediaPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EventMediaFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventMediaPayload>
        }
        findFirst: {
          args: Prisma.EventMediaFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventMediaPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EventMediaFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventMediaPayload>
        }
        findMany: {
          args: Prisma.EventMediaFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventMediaPayload>[]
        }
        create: {
          args: Prisma.EventMediaCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventMediaPayload>
        }
        createMany: {
          args: Prisma.EventMediaCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EventMediaCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventMediaPayload>[]
        }
        delete: {
          args: Prisma.EventMediaDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventMediaPayload>
        }
        update: {
          args: Prisma.EventMediaUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventMediaPayload>
        }
        deleteMany: {
          args: Prisma.EventMediaDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EventMediaUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EventMediaUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventMediaPayload>[]
        }
        upsert: {
          args: Prisma.EventMediaUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventMediaPayload>
        }
        aggregate: {
          args: Prisma.EventMediaAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEventMedia>
        }
        groupBy: {
          args: Prisma.EventMediaGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventMediaGroupByOutputType>[]
        }
        count: {
          args: Prisma.EventMediaCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventMediaCountAggregateOutputType> | number
        }
      }
    }
    EventTicketType: {
      payload: Prisma.$EventTicketTypePayload<ExtArgs>
      fields: Prisma.EventTicketTypeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EventTicketTypeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventTicketTypePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EventTicketTypeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventTicketTypePayload>
        }
        findFirst: {
          args: Prisma.EventTicketTypeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventTicketTypePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EventTicketTypeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventTicketTypePayload>
        }
        findMany: {
          args: Prisma.EventTicketTypeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventTicketTypePayload>[]
        }
        create: {
          args: Prisma.EventTicketTypeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventTicketTypePayload>
        }
        createMany: {
          args: Prisma.EventTicketTypeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EventTicketTypeCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventTicketTypePayload>[]
        }
        delete: {
          args: Prisma.EventTicketTypeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventTicketTypePayload>
        }
        update: {
          args: Prisma.EventTicketTypeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventTicketTypePayload>
        }
        deleteMany: {
          args: Prisma.EventTicketTypeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EventTicketTypeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EventTicketTypeUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventTicketTypePayload>[]
        }
        upsert: {
          args: Prisma.EventTicketTypeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventTicketTypePayload>
        }
        aggregate: {
          args: Prisma.EventTicketTypeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEventTicketType>
        }
        groupBy: {
          args: Prisma.EventTicketTypeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventTicketTypeGroupByOutputType>[]
        }
        count: {
          args: Prisma.EventTicketTypeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventTicketTypeCountAggregateOutputType> | number
        }
      }
    }
    EventTicketOrder: {
      payload: Prisma.$EventTicketOrderPayload<ExtArgs>
      fields: Prisma.EventTicketOrderFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EventTicketOrderFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventTicketOrderPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EventTicketOrderFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventTicketOrderPayload>
        }
        findFirst: {
          args: Prisma.EventTicketOrderFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventTicketOrderPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EventTicketOrderFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventTicketOrderPayload>
        }
        findMany: {
          args: Prisma.EventTicketOrderFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventTicketOrderPayload>[]
        }
        create: {
          args: Prisma.EventTicketOrderCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventTicketOrderPayload>
        }
        createMany: {
          args: Prisma.EventTicketOrderCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EventTicketOrderCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventTicketOrderPayload>[]
        }
        delete: {
          args: Prisma.EventTicketOrderDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventTicketOrderPayload>
        }
        update: {
          args: Prisma.EventTicketOrderUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventTicketOrderPayload>
        }
        deleteMany: {
          args: Prisma.EventTicketOrderDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EventTicketOrderUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EventTicketOrderUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventTicketOrderPayload>[]
        }
        upsert: {
          args: Prisma.EventTicketOrderUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventTicketOrderPayload>
        }
        aggregate: {
          args: Prisma.EventTicketOrderAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEventTicketOrder>
        }
        groupBy: {
          args: Prisma.EventTicketOrderGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventTicketOrderGroupByOutputType>[]
        }
        count: {
          args: Prisma.EventTicketOrderCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventTicketOrderCountAggregateOutputType> | number
        }
      }
    }
    Conversation: {
      payload: Prisma.$ConversationPayload<ExtArgs>
      fields: Prisma.ConversationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ConversationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ConversationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationPayload>
        }
        findFirst: {
          args: Prisma.ConversationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ConversationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationPayload>
        }
        findMany: {
          args: Prisma.ConversationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationPayload>[]
        }
        create: {
          args: Prisma.ConversationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationPayload>
        }
        createMany: {
          args: Prisma.ConversationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ConversationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationPayload>[]
        }
        delete: {
          args: Prisma.ConversationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationPayload>
        }
        update: {
          args: Prisma.ConversationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationPayload>
        }
        deleteMany: {
          args: Prisma.ConversationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ConversationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ConversationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationPayload>[]
        }
        upsert: {
          args: Prisma.ConversationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationPayload>
        }
        aggregate: {
          args: Prisma.ConversationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateConversation>
        }
        groupBy: {
          args: Prisma.ConversationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConversationGroupByOutputType>[]
        }
        count: {
          args: Prisma.ConversationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConversationCountAggregateOutputType> | number
        }
      }
    }
    ConversationMember: {
      payload: Prisma.$ConversationMemberPayload<ExtArgs>
      fields: Prisma.ConversationMemberFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ConversationMemberFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationMemberPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ConversationMemberFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationMemberPayload>
        }
        findFirst: {
          args: Prisma.ConversationMemberFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationMemberPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ConversationMemberFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationMemberPayload>
        }
        findMany: {
          args: Prisma.ConversationMemberFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationMemberPayload>[]
        }
        create: {
          args: Prisma.ConversationMemberCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationMemberPayload>
        }
        createMany: {
          args: Prisma.ConversationMemberCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ConversationMemberCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationMemberPayload>[]
        }
        delete: {
          args: Prisma.ConversationMemberDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationMemberPayload>
        }
        update: {
          args: Prisma.ConversationMemberUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationMemberPayload>
        }
        deleteMany: {
          args: Prisma.ConversationMemberDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ConversationMemberUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ConversationMemberUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationMemberPayload>[]
        }
        upsert: {
          args: Prisma.ConversationMemberUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationMemberPayload>
        }
        aggregate: {
          args: Prisma.ConversationMemberAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateConversationMember>
        }
        groupBy: {
          args: Prisma.ConversationMemberGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConversationMemberGroupByOutputType>[]
        }
        count: {
          args: Prisma.ConversationMemberCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConversationMemberCountAggregateOutputType> | number
        }
      }
    }
    Message: {
      payload: Prisma.$MessagePayload<ExtArgs>
      fields: Prisma.MessageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MessageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>
        }
        findFirst: {
          args: Prisma.MessageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>
        }
        findMany: {
          args: Prisma.MessageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>[]
        }
        create: {
          args: Prisma.MessageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>
        }
        createMany: {
          args: Prisma.MessageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>[]
        }
        delete: {
          args: Prisma.MessageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>
        }
        update: {
          args: Prisma.MessageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>
        }
        deleteMany: {
          args: Prisma.MessageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MessageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MessageUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>[]
        }
        upsert: {
          args: Prisma.MessageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>
        }
        aggregate: {
          args: Prisma.MessageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMessage>
        }
        groupBy: {
          args: Prisma.MessageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MessageGroupByOutputType>[]
        }
        count: {
          args: Prisma.MessageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MessageCountAggregateOutputType> | number
        }
      }
    }
    MediaAsset: {
      payload: Prisma.$MediaAssetPayload<ExtArgs>
      fields: Prisma.MediaAssetFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MediaAssetFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MediaAssetPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MediaAssetFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MediaAssetPayload>
        }
        findFirst: {
          args: Prisma.MediaAssetFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MediaAssetPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MediaAssetFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MediaAssetPayload>
        }
        findMany: {
          args: Prisma.MediaAssetFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MediaAssetPayload>[]
        }
        create: {
          args: Prisma.MediaAssetCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MediaAssetPayload>
        }
        createMany: {
          args: Prisma.MediaAssetCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MediaAssetCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MediaAssetPayload>[]
        }
        delete: {
          args: Prisma.MediaAssetDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MediaAssetPayload>
        }
        update: {
          args: Prisma.MediaAssetUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MediaAssetPayload>
        }
        deleteMany: {
          args: Prisma.MediaAssetDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MediaAssetUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MediaAssetUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MediaAssetPayload>[]
        }
        upsert: {
          args: Prisma.MediaAssetUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MediaAssetPayload>
        }
        aggregate: {
          args: Prisma.MediaAssetAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMediaAsset>
        }
        groupBy: {
          args: Prisma.MediaAssetGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MediaAssetGroupByOutputType>[]
        }
        count: {
          args: Prisma.MediaAssetCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MediaAssetCountAggregateOutputType> | number
        }
      }
    }
    NotificationPreference: {
      payload: Prisma.$NotificationPreferencePayload<ExtArgs>
      fields: Prisma.NotificationPreferenceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.NotificationPreferenceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
        }
        findFirst: {
          args: Prisma.NotificationPreferenceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.NotificationPreferenceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
        }
        findMany: {
          args: Prisma.NotificationPreferenceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
        }
        create: {
          args: Prisma.NotificationPreferenceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
        }
        createMany: {
          args: Prisma.NotificationPreferenceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.NotificationPreferenceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
        }
        delete: {
          args: Prisma.NotificationPreferenceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
        }
        update: {
          args: Prisma.NotificationPreferenceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
        }
        deleteMany: {
          args: Prisma.NotificationPreferenceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.NotificationPreferenceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.NotificationPreferenceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
        }
        upsert: {
          args: Prisma.NotificationPreferenceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
        }
        aggregate: {
          args: Prisma.NotificationPreferenceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNotificationPreference>
        }
        groupBy: {
          args: Prisma.NotificationPreferenceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NotificationPreferenceGroupByOutputType>[]
        }
        count: {
          args: Prisma.NotificationPreferenceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NotificationPreferenceCountAggregateOutputType> | number
        }
      }
    }
    InAppNotification: {
      payload: Prisma.$InAppNotificationPayload<ExtArgs>
      fields: Prisma.InAppNotificationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.InAppNotificationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InAppNotificationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.InAppNotificationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InAppNotificationPayload>
        }
        findFirst: {
          args: Prisma.InAppNotificationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InAppNotificationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.InAppNotificationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InAppNotificationPayload>
        }
        findMany: {
          args: Prisma.InAppNotificationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InAppNotificationPayload>[]
        }
        create: {
          args: Prisma.InAppNotificationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InAppNotificationPayload>
        }
        createMany: {
          args: Prisma.InAppNotificationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.InAppNotificationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InAppNotificationPayload>[]
        }
        delete: {
          args: Prisma.InAppNotificationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InAppNotificationPayload>
        }
        update: {
          args: Prisma.InAppNotificationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InAppNotificationPayload>
        }
        deleteMany: {
          args: Prisma.InAppNotificationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.InAppNotificationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.InAppNotificationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InAppNotificationPayload>[]
        }
        upsert: {
          args: Prisma.InAppNotificationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InAppNotificationPayload>
        }
        aggregate: {
          args: Prisma.InAppNotificationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateInAppNotification>
        }
        groupBy: {
          args: Prisma.InAppNotificationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InAppNotificationGroupByOutputType>[]
        }
        count: {
          args: Prisma.InAppNotificationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InAppNotificationCountAggregateOutputType> | number
        }
      }
    }
    DeviceToken: {
      payload: Prisma.$DeviceTokenPayload<ExtArgs>
      fields: Prisma.DeviceTokenFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DeviceTokenFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeviceTokenPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DeviceTokenFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeviceTokenPayload>
        }
        findFirst: {
          args: Prisma.DeviceTokenFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeviceTokenPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DeviceTokenFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeviceTokenPayload>
        }
        findMany: {
          args: Prisma.DeviceTokenFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeviceTokenPayload>[]
        }
        create: {
          args: Prisma.DeviceTokenCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeviceTokenPayload>
        }
        createMany: {
          args: Prisma.DeviceTokenCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DeviceTokenCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeviceTokenPayload>[]
        }
        delete: {
          args: Prisma.DeviceTokenDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeviceTokenPayload>
        }
        update: {
          args: Prisma.DeviceTokenUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeviceTokenPayload>
        }
        deleteMany: {
          args: Prisma.DeviceTokenDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DeviceTokenUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DeviceTokenUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeviceTokenPayload>[]
        }
        upsert: {
          args: Prisma.DeviceTokenUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeviceTokenPayload>
        }
        aggregate: {
          args: Prisma.DeviceTokenAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDeviceToken>
        }
        groupBy: {
          args: Prisma.DeviceTokenGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DeviceTokenGroupByOutputType>[]
        }
        count: {
          args: Prisma.DeviceTokenCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DeviceTokenCountAggregateOutputType> | number
        }
      }
    }
    Attendance: {
      payload: Prisma.$AttendancePayload<ExtArgs>
      fields: Prisma.AttendanceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AttendanceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendancePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AttendanceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendancePayload>
        }
        findFirst: {
          args: Prisma.AttendanceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendancePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AttendanceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendancePayload>
        }
        findMany: {
          args: Prisma.AttendanceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendancePayload>[]
        }
        create: {
          args: Prisma.AttendanceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendancePayload>
        }
        createMany: {
          args: Prisma.AttendanceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AttendanceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendancePayload>[]
        }
        delete: {
          args: Prisma.AttendanceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendancePayload>
        }
        update: {
          args: Prisma.AttendanceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendancePayload>
        }
        deleteMany: {
          args: Prisma.AttendanceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AttendanceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AttendanceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendancePayload>[]
        }
        upsert: {
          args: Prisma.AttendanceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendancePayload>
        }
        aggregate: {
          args: Prisma.AttendanceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAttendance>
        }
        groupBy: {
          args: Prisma.AttendanceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AttendanceGroupByOutputType>[]
        }
        count: {
          args: Prisma.AttendanceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AttendanceCountAggregateOutputType> | number
        }
      }
    }
    MemberRelationship: {
      payload: Prisma.$MemberRelationshipPayload<ExtArgs>
      fields: Prisma.MemberRelationshipFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MemberRelationshipFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberRelationshipPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MemberRelationshipFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberRelationshipPayload>
        }
        findFirst: {
          args: Prisma.MemberRelationshipFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberRelationshipPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MemberRelationshipFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberRelationshipPayload>
        }
        findMany: {
          args: Prisma.MemberRelationshipFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberRelationshipPayload>[]
        }
        create: {
          args: Prisma.MemberRelationshipCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberRelationshipPayload>
        }
        createMany: {
          args: Prisma.MemberRelationshipCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MemberRelationshipCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberRelationshipPayload>[]
        }
        delete: {
          args: Prisma.MemberRelationshipDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberRelationshipPayload>
        }
        update: {
          args: Prisma.MemberRelationshipUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberRelationshipPayload>
        }
        deleteMany: {
          args: Prisma.MemberRelationshipDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MemberRelationshipUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MemberRelationshipUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberRelationshipPayload>[]
        }
        upsert: {
          args: Prisma.MemberRelationshipUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberRelationshipPayload>
        }
        aggregate: {
          args: Prisma.MemberRelationshipAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMemberRelationship>
        }
        groupBy: {
          args: Prisma.MemberRelationshipGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MemberRelationshipGroupByOutputType>[]
        }
        count: {
          args: Prisma.MemberRelationshipCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MemberRelationshipCountAggregateOutputType> | number
        }
      }
    }
    Donation: {
      payload: Prisma.$DonationPayload<ExtArgs>
      fields: Prisma.DonationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DonationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DonationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DonationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DonationPayload>
        }
        findFirst: {
          args: Prisma.DonationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DonationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DonationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DonationPayload>
        }
        findMany: {
          args: Prisma.DonationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DonationPayload>[]
        }
        create: {
          args: Prisma.DonationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DonationPayload>
        }
        createMany: {
          args: Prisma.DonationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DonationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DonationPayload>[]
        }
        delete: {
          args: Prisma.DonationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DonationPayload>
        }
        update: {
          args: Prisma.DonationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DonationPayload>
        }
        deleteMany: {
          args: Prisma.DonationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DonationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DonationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DonationPayload>[]
        }
        upsert: {
          args: Prisma.DonationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DonationPayload>
        }
        aggregate: {
          args: Prisma.DonationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDonation>
        }
        groupBy: {
          args: Prisma.DonationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DonationGroupByOutputType>[]
        }
        count: {
          args: Prisma.DonationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DonationCountAggregateOutputType> | number
        }
      }
    }
    Fund: {
      payload: Prisma.$FundPayload<ExtArgs>
      fields: Prisma.FundFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FundFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FundPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FundFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FundPayload>
        }
        findFirst: {
          args: Prisma.FundFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FundPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FundFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FundPayload>
        }
        findMany: {
          args: Prisma.FundFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FundPayload>[]
        }
        create: {
          args: Prisma.FundCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FundPayload>
        }
        createMany: {
          args: Prisma.FundCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FundCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FundPayload>[]
        }
        delete: {
          args: Prisma.FundDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FundPayload>
        }
        update: {
          args: Prisma.FundUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FundPayload>
        }
        deleteMany: {
          args: Prisma.FundDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FundUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FundUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FundPayload>[]
        }
        upsert: {
          args: Prisma.FundUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FundPayload>
        }
        aggregate: {
          args: Prisma.FundAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFund>
        }
        groupBy: {
          args: Prisma.FundGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FundGroupByOutputType>[]
        }
        count: {
          args: Prisma.FundCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FundCountAggregateOutputType> | number
        }
      }
    }
    Campaign: {
      payload: Prisma.$CampaignPayload<ExtArgs>
      fields: Prisma.CampaignFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CampaignFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CampaignFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignPayload>
        }
        findFirst: {
          args: Prisma.CampaignFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CampaignFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignPayload>
        }
        findMany: {
          args: Prisma.CampaignFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignPayload>[]
        }
        create: {
          args: Prisma.CampaignCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignPayload>
        }
        createMany: {
          args: Prisma.CampaignCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CampaignCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignPayload>[]
        }
        delete: {
          args: Prisma.CampaignDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignPayload>
        }
        update: {
          args: Prisma.CampaignUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignPayload>
        }
        deleteMany: {
          args: Prisma.CampaignDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CampaignUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CampaignUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignPayload>[]
        }
        upsert: {
          args: Prisma.CampaignUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignPayload>
        }
        aggregate: {
          args: Prisma.CampaignAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCampaign>
        }
        groupBy: {
          args: Prisma.CampaignGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CampaignGroupByOutputType>[]
        }
        count: {
          args: Prisma.CampaignCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CampaignCountAggregateOutputType> | number
        }
      }
    }
    PaymentIntent: {
      payload: Prisma.$PaymentIntentPayload<ExtArgs>
      fields: Prisma.PaymentIntentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PaymentIntentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentIntentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PaymentIntentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentIntentPayload>
        }
        findFirst: {
          args: Prisma.PaymentIntentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentIntentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PaymentIntentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentIntentPayload>
        }
        findMany: {
          args: Prisma.PaymentIntentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentIntentPayload>[]
        }
        create: {
          args: Prisma.PaymentIntentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentIntentPayload>
        }
        createMany: {
          args: Prisma.PaymentIntentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PaymentIntentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentIntentPayload>[]
        }
        delete: {
          args: Prisma.PaymentIntentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentIntentPayload>
        }
        update: {
          args: Prisma.PaymentIntentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentIntentPayload>
        }
        deleteMany: {
          args: Prisma.PaymentIntentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PaymentIntentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PaymentIntentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentIntentPayload>[]
        }
        upsert: {
          args: Prisma.PaymentIntentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentIntentPayload>
        }
        aggregate: {
          args: Prisma.PaymentIntentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePaymentIntent>
        }
        groupBy: {
          args: Prisma.PaymentIntentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PaymentIntentGroupByOutputType>[]
        }
        count: {
          args: Prisma.PaymentIntentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PaymentIntentCountAggregateOutputType> | number
        }
      }
    }
    DonationReceipt: {
      payload: Prisma.$DonationReceiptPayload<ExtArgs>
      fields: Prisma.DonationReceiptFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DonationReceiptFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DonationReceiptPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DonationReceiptFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DonationReceiptPayload>
        }
        findFirst: {
          args: Prisma.DonationReceiptFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DonationReceiptPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DonationReceiptFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DonationReceiptPayload>
        }
        findMany: {
          args: Prisma.DonationReceiptFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DonationReceiptPayload>[]
        }
        create: {
          args: Prisma.DonationReceiptCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DonationReceiptPayload>
        }
        createMany: {
          args: Prisma.DonationReceiptCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DonationReceiptCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DonationReceiptPayload>[]
        }
        delete: {
          args: Prisma.DonationReceiptDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DonationReceiptPayload>
        }
        update: {
          args: Prisma.DonationReceiptUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DonationReceiptPayload>
        }
        deleteMany: {
          args: Prisma.DonationReceiptDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DonationReceiptUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DonationReceiptUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DonationReceiptPayload>[]
        }
        upsert: {
          args: Prisma.DonationReceiptUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DonationReceiptPayload>
        }
        aggregate: {
          args: Prisma.DonationReceiptAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDonationReceipt>
        }
        groupBy: {
          args: Prisma.DonationReceiptGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DonationReceiptGroupByOutputType>[]
        }
        count: {
          args: Prisma.DonationReceiptCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DonationReceiptCountAggregateOutputType> | number
        }
      }
    }
    TextToGiveNumber: {
      payload: Prisma.$TextToGiveNumberPayload<ExtArgs>
      fields: Prisma.TextToGiveNumberFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TextToGiveNumberFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TextToGiveNumberPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TextToGiveNumberFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TextToGiveNumberPayload>
        }
        findFirst: {
          args: Prisma.TextToGiveNumberFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TextToGiveNumberPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TextToGiveNumberFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TextToGiveNumberPayload>
        }
        findMany: {
          args: Prisma.TextToGiveNumberFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TextToGiveNumberPayload>[]
        }
        create: {
          args: Prisma.TextToGiveNumberCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TextToGiveNumberPayload>
        }
        createMany: {
          args: Prisma.TextToGiveNumberCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TextToGiveNumberCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TextToGiveNumberPayload>[]
        }
        delete: {
          args: Prisma.TextToGiveNumberDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TextToGiveNumberPayload>
        }
        update: {
          args: Prisma.TextToGiveNumberUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TextToGiveNumberPayload>
        }
        deleteMany: {
          args: Prisma.TextToGiveNumberDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TextToGiveNumberUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TextToGiveNumberUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TextToGiveNumberPayload>[]
        }
        upsert: {
          args: Prisma.TextToGiveNumberUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TextToGiveNumberPayload>
        }
        aggregate: {
          args: Prisma.TextToGiveNumberAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTextToGiveNumber>
        }
        groupBy: {
          args: Prisma.TextToGiveNumberGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TextToGiveNumberGroupByOutputType>[]
        }
        count: {
          args: Prisma.TextToGiveNumberCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TextToGiveNumberCountAggregateOutputType> | number
        }
      }
    }
    TextToGiveMessage: {
      payload: Prisma.$TextToGiveMessagePayload<ExtArgs>
      fields: Prisma.TextToGiveMessageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TextToGiveMessageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TextToGiveMessagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TextToGiveMessageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TextToGiveMessagePayload>
        }
        findFirst: {
          args: Prisma.TextToGiveMessageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TextToGiveMessagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TextToGiveMessageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TextToGiveMessagePayload>
        }
        findMany: {
          args: Prisma.TextToGiveMessageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TextToGiveMessagePayload>[]
        }
        create: {
          args: Prisma.TextToGiveMessageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TextToGiveMessagePayload>
        }
        createMany: {
          args: Prisma.TextToGiveMessageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TextToGiveMessageCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TextToGiveMessagePayload>[]
        }
        delete: {
          args: Prisma.TextToGiveMessageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TextToGiveMessagePayload>
        }
        update: {
          args: Prisma.TextToGiveMessageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TextToGiveMessagePayload>
        }
        deleteMany: {
          args: Prisma.TextToGiveMessageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TextToGiveMessageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TextToGiveMessageUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TextToGiveMessagePayload>[]
        }
        upsert: {
          args: Prisma.TextToGiveMessageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TextToGiveMessagePayload>
        }
        aggregate: {
          args: Prisma.TextToGiveMessageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTextToGiveMessage>
        }
        groupBy: {
          args: Prisma.TextToGiveMessageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TextToGiveMessageGroupByOutputType>[]
        }
        count: {
          args: Prisma.TextToGiveMessageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TextToGiveMessageCountAggregateOutputType> | number
        }
      }
    }
    Payout: {
      payload: Prisma.$PayoutPayload<ExtArgs>
      fields: Prisma.PayoutFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PayoutFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayoutPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PayoutFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayoutPayload>
        }
        findFirst: {
          args: Prisma.PayoutFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayoutPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PayoutFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayoutPayload>
        }
        findMany: {
          args: Prisma.PayoutFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayoutPayload>[]
        }
        create: {
          args: Prisma.PayoutCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayoutPayload>
        }
        createMany: {
          args: Prisma.PayoutCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PayoutCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayoutPayload>[]
        }
        delete: {
          args: Prisma.PayoutDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayoutPayload>
        }
        update: {
          args: Prisma.PayoutUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayoutPayload>
        }
        deleteMany: {
          args: Prisma.PayoutDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PayoutUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PayoutUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayoutPayload>[]
        }
        upsert: {
          args: Prisma.PayoutUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayoutPayload>
        }
        aggregate: {
          args: Prisma.PayoutAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePayout>
        }
        groupBy: {
          args: Prisma.PayoutGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PayoutGroupByOutputType>[]
        }
        count: {
          args: Prisma.PayoutCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PayoutCountAggregateOutputType> | number
        }
      }
    }
    PayoutTransaction: {
      payload: Prisma.$PayoutTransactionPayload<ExtArgs>
      fields: Prisma.PayoutTransactionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PayoutTransactionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayoutTransactionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PayoutTransactionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayoutTransactionPayload>
        }
        findFirst: {
          args: Prisma.PayoutTransactionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayoutTransactionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PayoutTransactionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayoutTransactionPayload>
        }
        findMany: {
          args: Prisma.PayoutTransactionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayoutTransactionPayload>[]
        }
        create: {
          args: Prisma.PayoutTransactionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayoutTransactionPayload>
        }
        createMany: {
          args: Prisma.PayoutTransactionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PayoutTransactionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayoutTransactionPayload>[]
        }
        delete: {
          args: Prisma.PayoutTransactionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayoutTransactionPayload>
        }
        update: {
          args: Prisma.PayoutTransactionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayoutTransactionPayload>
        }
        deleteMany: {
          args: Prisma.PayoutTransactionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PayoutTransactionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PayoutTransactionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayoutTransactionPayload>[]
        }
        upsert: {
          args: Prisma.PayoutTransactionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayoutTransactionPayload>
        }
        aggregate: {
          args: Prisma.PayoutTransactionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePayoutTransaction>
        }
        groupBy: {
          args: Prisma.PayoutTransactionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PayoutTransactionGroupByOutputType>[]
        }
        count: {
          args: Prisma.PayoutTransactionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PayoutTransactionCountAggregateOutputType> | number
        }
      }
    }
    Refund: {
      payload: Prisma.$RefundPayload<ExtArgs>
      fields: Prisma.RefundFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RefundFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefundPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RefundFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefundPayload>
        }
        findFirst: {
          args: Prisma.RefundFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefundPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RefundFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefundPayload>
        }
        findMany: {
          args: Prisma.RefundFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefundPayload>[]
        }
        create: {
          args: Prisma.RefundCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefundPayload>
        }
        createMany: {
          args: Prisma.RefundCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RefundCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefundPayload>[]
        }
        delete: {
          args: Prisma.RefundDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefundPayload>
        }
        update: {
          args: Prisma.RefundUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefundPayload>
        }
        deleteMany: {
          args: Prisma.RefundDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RefundUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RefundUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefundPayload>[]
        }
        upsert: {
          args: Prisma.RefundUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefundPayload>
        }
        aggregate: {
          args: Prisma.RefundAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRefund>
        }
        groupBy: {
          args: Prisma.RefundGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RefundGroupByOutputType>[]
        }
        count: {
          args: Prisma.RefundCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RefundCountAggregateOutputType> | number
        }
      }
    }
    Dispute: {
      payload: Prisma.$DisputePayload<ExtArgs>
      fields: Prisma.DisputeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DisputeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DisputePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DisputeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DisputePayload>
        }
        findFirst: {
          args: Prisma.DisputeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DisputePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DisputeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DisputePayload>
        }
        findMany: {
          args: Prisma.DisputeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DisputePayload>[]
        }
        create: {
          args: Prisma.DisputeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DisputePayload>
        }
        createMany: {
          args: Prisma.DisputeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DisputeCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DisputePayload>[]
        }
        delete: {
          args: Prisma.DisputeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DisputePayload>
        }
        update: {
          args: Prisma.DisputeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DisputePayload>
        }
        deleteMany: {
          args: Prisma.DisputeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DisputeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DisputeUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DisputePayload>[]
        }
        upsert: {
          args: Prisma.DisputeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DisputePayload>
        }
        aggregate: {
          args: Prisma.DisputeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDispute>
        }
        groupBy: {
          args: Prisma.DisputeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DisputeGroupByOutputType>[]
        }
        count: {
          args: Prisma.DisputeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DisputeCountAggregateOutputType> | number
        }
      }
    }
    DisputeEvidence: {
      payload: Prisma.$DisputeEvidencePayload<ExtArgs>
      fields: Prisma.DisputeEvidenceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DisputeEvidenceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DisputeEvidencePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DisputeEvidenceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DisputeEvidencePayload>
        }
        findFirst: {
          args: Prisma.DisputeEvidenceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DisputeEvidencePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DisputeEvidenceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DisputeEvidencePayload>
        }
        findMany: {
          args: Prisma.DisputeEvidenceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DisputeEvidencePayload>[]
        }
        create: {
          args: Prisma.DisputeEvidenceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DisputeEvidencePayload>
        }
        createMany: {
          args: Prisma.DisputeEvidenceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DisputeEvidenceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DisputeEvidencePayload>[]
        }
        delete: {
          args: Prisma.DisputeEvidenceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DisputeEvidencePayload>
        }
        update: {
          args: Prisma.DisputeEvidenceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DisputeEvidencePayload>
        }
        deleteMany: {
          args: Prisma.DisputeEvidenceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DisputeEvidenceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DisputeEvidenceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DisputeEvidencePayload>[]
        }
        upsert: {
          args: Prisma.DisputeEvidenceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DisputeEvidencePayload>
        }
        aggregate: {
          args: Prisma.DisputeEvidenceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDisputeEvidence>
        }
        groupBy: {
          args: Prisma.DisputeEvidenceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DisputeEvidenceGroupByOutputType>[]
        }
        count: {
          args: Prisma.DisputeEvidenceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DisputeEvidenceCountAggregateOutputType> | number
        }
      }
    }
    CommunicationSchedule: {
      payload: Prisma.$CommunicationSchedulePayload<ExtArgs>
      fields: Prisma.CommunicationScheduleFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CommunicationScheduleFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationSchedulePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CommunicationScheduleFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationSchedulePayload>
        }
        findFirst: {
          args: Prisma.CommunicationScheduleFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationSchedulePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CommunicationScheduleFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationSchedulePayload>
        }
        findMany: {
          args: Prisma.CommunicationScheduleFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationSchedulePayload>[]
        }
        create: {
          args: Prisma.CommunicationScheduleCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationSchedulePayload>
        }
        createMany: {
          args: Prisma.CommunicationScheduleCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CommunicationScheduleCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationSchedulePayload>[]
        }
        delete: {
          args: Prisma.CommunicationScheduleDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationSchedulePayload>
        }
        update: {
          args: Prisma.CommunicationScheduleUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationSchedulePayload>
        }
        deleteMany: {
          args: Prisma.CommunicationScheduleDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CommunicationScheduleUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CommunicationScheduleUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationSchedulePayload>[]
        }
        upsert: {
          args: Prisma.CommunicationScheduleUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationSchedulePayload>
        }
        aggregate: {
          args: Prisma.CommunicationScheduleAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCommunicationSchedule>
        }
        groupBy: {
          args: Prisma.CommunicationScheduleGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CommunicationScheduleGroupByOutputType>[]
        }
        count: {
          args: Prisma.CommunicationScheduleCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CommunicationScheduleCountAggregateOutputType> | number
        }
      }
    }
    CommunicationDripCampaign: {
      payload: Prisma.$CommunicationDripCampaignPayload<ExtArgs>
      fields: Prisma.CommunicationDripCampaignFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CommunicationDripCampaignFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationDripCampaignPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CommunicationDripCampaignFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationDripCampaignPayload>
        }
        findFirst: {
          args: Prisma.CommunicationDripCampaignFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationDripCampaignPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CommunicationDripCampaignFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationDripCampaignPayload>
        }
        findMany: {
          args: Prisma.CommunicationDripCampaignFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationDripCampaignPayload>[]
        }
        create: {
          args: Prisma.CommunicationDripCampaignCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationDripCampaignPayload>
        }
        createMany: {
          args: Prisma.CommunicationDripCampaignCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CommunicationDripCampaignCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationDripCampaignPayload>[]
        }
        delete: {
          args: Prisma.CommunicationDripCampaignDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationDripCampaignPayload>
        }
        update: {
          args: Prisma.CommunicationDripCampaignUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationDripCampaignPayload>
        }
        deleteMany: {
          args: Prisma.CommunicationDripCampaignDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CommunicationDripCampaignUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CommunicationDripCampaignUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationDripCampaignPayload>[]
        }
        upsert: {
          args: Prisma.CommunicationDripCampaignUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationDripCampaignPayload>
        }
        aggregate: {
          args: Prisma.CommunicationDripCampaignAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCommunicationDripCampaign>
        }
        groupBy: {
          args: Prisma.CommunicationDripCampaignGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CommunicationDripCampaignGroupByOutputType>[]
        }
        count: {
          args: Prisma.CommunicationDripCampaignCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CommunicationDripCampaignCountAggregateOutputType> | number
        }
      }
    }
    CommunicationDripStep: {
      payload: Prisma.$CommunicationDripStepPayload<ExtArgs>
      fields: Prisma.CommunicationDripStepFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CommunicationDripStepFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationDripStepPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CommunicationDripStepFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationDripStepPayload>
        }
        findFirst: {
          args: Prisma.CommunicationDripStepFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationDripStepPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CommunicationDripStepFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationDripStepPayload>
        }
        findMany: {
          args: Prisma.CommunicationDripStepFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationDripStepPayload>[]
        }
        create: {
          args: Prisma.CommunicationDripStepCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationDripStepPayload>
        }
        createMany: {
          args: Prisma.CommunicationDripStepCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CommunicationDripStepCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationDripStepPayload>[]
        }
        delete: {
          args: Prisma.CommunicationDripStepDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationDripStepPayload>
        }
        update: {
          args: Prisma.CommunicationDripStepUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationDripStepPayload>
        }
        deleteMany: {
          args: Prisma.CommunicationDripStepDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CommunicationDripStepUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CommunicationDripStepUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationDripStepPayload>[]
        }
        upsert: {
          args: Prisma.CommunicationDripStepUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationDripStepPayload>
        }
        aggregate: {
          args: Prisma.CommunicationDripStepAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCommunicationDripStep>
        }
        groupBy: {
          args: Prisma.CommunicationDripStepGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CommunicationDripStepGroupByOutputType>[]
        }
        count: {
          args: Prisma.CommunicationDripStepCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CommunicationDripStepCountAggregateOutputType> | number
        }
      }
    }
    CommunicationDripEnrollment: {
      payload: Prisma.$CommunicationDripEnrollmentPayload<ExtArgs>
      fields: Prisma.CommunicationDripEnrollmentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CommunicationDripEnrollmentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationDripEnrollmentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CommunicationDripEnrollmentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationDripEnrollmentPayload>
        }
        findFirst: {
          args: Prisma.CommunicationDripEnrollmentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationDripEnrollmentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CommunicationDripEnrollmentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationDripEnrollmentPayload>
        }
        findMany: {
          args: Prisma.CommunicationDripEnrollmentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationDripEnrollmentPayload>[]
        }
        create: {
          args: Prisma.CommunicationDripEnrollmentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationDripEnrollmentPayload>
        }
        createMany: {
          args: Prisma.CommunicationDripEnrollmentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CommunicationDripEnrollmentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationDripEnrollmentPayload>[]
        }
        delete: {
          args: Prisma.CommunicationDripEnrollmentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationDripEnrollmentPayload>
        }
        update: {
          args: Prisma.CommunicationDripEnrollmentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationDripEnrollmentPayload>
        }
        deleteMany: {
          args: Prisma.CommunicationDripEnrollmentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CommunicationDripEnrollmentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CommunicationDripEnrollmentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationDripEnrollmentPayload>[]
        }
        upsert: {
          args: Prisma.CommunicationDripEnrollmentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationDripEnrollmentPayload>
        }
        aggregate: {
          args: Prisma.CommunicationDripEnrollmentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCommunicationDripEnrollment>
        }
        groupBy: {
          args: Prisma.CommunicationDripEnrollmentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CommunicationDripEnrollmentGroupByOutputType>[]
        }
        count: {
          args: Prisma.CommunicationDripEnrollmentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CommunicationDripEnrollmentCountAggregateOutputType> | number
        }
      }
    }
    CommunicationTemplate: {
      payload: Prisma.$CommunicationTemplatePayload<ExtArgs>
      fields: Prisma.CommunicationTemplateFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CommunicationTemplateFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationTemplatePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CommunicationTemplateFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationTemplatePayload>
        }
        findFirst: {
          args: Prisma.CommunicationTemplateFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationTemplatePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CommunicationTemplateFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationTemplatePayload>
        }
        findMany: {
          args: Prisma.CommunicationTemplateFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationTemplatePayload>[]
        }
        create: {
          args: Prisma.CommunicationTemplateCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationTemplatePayload>
        }
        createMany: {
          args: Prisma.CommunicationTemplateCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CommunicationTemplateCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationTemplatePayload>[]
        }
        delete: {
          args: Prisma.CommunicationTemplateDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationTemplatePayload>
        }
        update: {
          args: Prisma.CommunicationTemplateUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationTemplatePayload>
        }
        deleteMany: {
          args: Prisma.CommunicationTemplateDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CommunicationTemplateUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CommunicationTemplateUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationTemplatePayload>[]
        }
        upsert: {
          args: Prisma.CommunicationTemplateUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationTemplatePayload>
        }
        aggregate: {
          args: Prisma.CommunicationTemplateAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCommunicationTemplate>
        }
        groupBy: {
          args: Prisma.CommunicationTemplateGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CommunicationTemplateGroupByOutputType>[]
        }
        count: {
          args: Prisma.CommunicationTemplateCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CommunicationTemplateCountAggregateOutputType> | number
        }
      }
    }
    CommunicationMessage: {
      payload: Prisma.$CommunicationMessagePayload<ExtArgs>
      fields: Prisma.CommunicationMessageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CommunicationMessageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationMessagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CommunicationMessageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationMessagePayload>
        }
        findFirst: {
          args: Prisma.CommunicationMessageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationMessagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CommunicationMessageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationMessagePayload>
        }
        findMany: {
          args: Prisma.CommunicationMessageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationMessagePayload>[]
        }
        create: {
          args: Prisma.CommunicationMessageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationMessagePayload>
        }
        createMany: {
          args: Prisma.CommunicationMessageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CommunicationMessageCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationMessagePayload>[]
        }
        delete: {
          args: Prisma.CommunicationMessageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationMessagePayload>
        }
        update: {
          args: Prisma.CommunicationMessageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationMessagePayload>
        }
        deleteMany: {
          args: Prisma.CommunicationMessageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CommunicationMessageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CommunicationMessageUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationMessagePayload>[]
        }
        upsert: {
          args: Prisma.CommunicationMessageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationMessagePayload>
        }
        aggregate: {
          args: Prisma.CommunicationMessageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCommunicationMessage>
        }
        groupBy: {
          args: Prisma.CommunicationMessageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CommunicationMessageGroupByOutputType>[]
        }
        count: {
          args: Prisma.CommunicationMessageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CommunicationMessageCountAggregateOutputType> | number
        }
      }
    }
    CommunicationSuppression: {
      payload: Prisma.$CommunicationSuppressionPayload<ExtArgs>
      fields: Prisma.CommunicationSuppressionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CommunicationSuppressionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationSuppressionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CommunicationSuppressionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationSuppressionPayload>
        }
        findFirst: {
          args: Prisma.CommunicationSuppressionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationSuppressionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CommunicationSuppressionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationSuppressionPayload>
        }
        findMany: {
          args: Prisma.CommunicationSuppressionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationSuppressionPayload>[]
        }
        create: {
          args: Prisma.CommunicationSuppressionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationSuppressionPayload>
        }
        createMany: {
          args: Prisma.CommunicationSuppressionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CommunicationSuppressionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationSuppressionPayload>[]
        }
        delete: {
          args: Prisma.CommunicationSuppressionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationSuppressionPayload>
        }
        update: {
          args: Prisma.CommunicationSuppressionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationSuppressionPayload>
        }
        deleteMany: {
          args: Prisma.CommunicationSuppressionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CommunicationSuppressionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CommunicationSuppressionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationSuppressionPayload>[]
        }
        upsert: {
          args: Prisma.CommunicationSuppressionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationSuppressionPayload>
        }
        aggregate: {
          args: Prisma.CommunicationSuppressionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCommunicationSuppression>
        }
        groupBy: {
          args: Prisma.CommunicationSuppressionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CommunicationSuppressionGroupByOutputType>[]
        }
        count: {
          args: Prisma.CommunicationSuppressionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CommunicationSuppressionCountAggregateOutputType> | number
        }
      }
    }
    AiInteraction: {
      payload: Prisma.$AiInteractionPayload<ExtArgs>
      fields: Prisma.AiInteractionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AiInteractionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiInteractionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AiInteractionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiInteractionPayload>
        }
        findFirst: {
          args: Prisma.AiInteractionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiInteractionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AiInteractionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiInteractionPayload>
        }
        findMany: {
          args: Prisma.AiInteractionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiInteractionPayload>[]
        }
        create: {
          args: Prisma.AiInteractionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiInteractionPayload>
        }
        createMany: {
          args: Prisma.AiInteractionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AiInteractionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiInteractionPayload>[]
        }
        delete: {
          args: Prisma.AiInteractionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiInteractionPayload>
        }
        update: {
          args: Prisma.AiInteractionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiInteractionPayload>
        }
        deleteMany: {
          args: Prisma.AiInteractionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AiInteractionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AiInteractionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiInteractionPayload>[]
        }
        upsert: {
          args: Prisma.AiInteractionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiInteractionPayload>
        }
        aggregate: {
          args: Prisma.AiInteractionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAiInteraction>
        }
        groupBy: {
          args: Prisma.AiInteractionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiInteractionGroupByOutputType>[]
        }
        count: {
          args: Prisma.AiInteractionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiInteractionCountAggregateOutputType> | number
        }
      }
    }
    FundraiserPage: {
      payload: Prisma.$FundraiserPagePayload<ExtArgs>
      fields: Prisma.FundraiserPageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FundraiserPageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FundraiserPagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FundraiserPageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FundraiserPagePayload>
        }
        findFirst: {
          args: Prisma.FundraiserPageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FundraiserPagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FundraiserPageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FundraiserPagePayload>
        }
        findMany: {
          args: Prisma.FundraiserPageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FundraiserPagePayload>[]
        }
        create: {
          args: Prisma.FundraiserPageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FundraiserPagePayload>
        }
        createMany: {
          args: Prisma.FundraiserPageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FundraiserPageCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FundraiserPagePayload>[]
        }
        delete: {
          args: Prisma.FundraiserPageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FundraiserPagePayload>
        }
        update: {
          args: Prisma.FundraiserPageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FundraiserPagePayload>
        }
        deleteMany: {
          args: Prisma.FundraiserPageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FundraiserPageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FundraiserPageUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FundraiserPagePayload>[]
        }
        upsert: {
          args: Prisma.FundraiserPageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FundraiserPagePayload>
        }
        aggregate: {
          args: Prisma.FundraiserPageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFundraiserPage>
        }
        groupBy: {
          args: Prisma.FundraiserPageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FundraiserPageGroupByOutputType>[]
        }
        count: {
          args: Prisma.FundraiserPageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FundraiserPageCountAggregateOutputType> | number
        }
      }
    }
    Pledge: {
      payload: Prisma.$PledgePayload<ExtArgs>
      fields: Prisma.PledgeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PledgeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PledgePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PledgeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PledgePayload>
        }
        findFirst: {
          args: Prisma.PledgeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PledgePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PledgeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PledgePayload>
        }
        findMany: {
          args: Prisma.PledgeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PledgePayload>[]
        }
        create: {
          args: Prisma.PledgeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PledgePayload>
        }
        createMany: {
          args: Prisma.PledgeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PledgeCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PledgePayload>[]
        }
        delete: {
          args: Prisma.PledgeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PledgePayload>
        }
        update: {
          args: Prisma.PledgeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PledgePayload>
        }
        deleteMany: {
          args: Prisma.PledgeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PledgeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PledgeUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PledgePayload>[]
        }
        upsert: {
          args: Prisma.PledgeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PledgePayload>
        }
        aggregate: {
          args: Prisma.PledgeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePledge>
        }
        groupBy: {
          args: Prisma.PledgeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PledgeGroupByOutputType>[]
        }
        count: {
          args: Prisma.PledgeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PledgeCountAggregateOutputType> | number
        }
      }
    }
    RecurringDonation: {
      payload: Prisma.$RecurringDonationPayload<ExtArgs>
      fields: Prisma.RecurringDonationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RecurringDonationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecurringDonationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RecurringDonationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecurringDonationPayload>
        }
        findFirst: {
          args: Prisma.RecurringDonationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecurringDonationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RecurringDonationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecurringDonationPayload>
        }
        findMany: {
          args: Prisma.RecurringDonationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecurringDonationPayload>[]
        }
        create: {
          args: Prisma.RecurringDonationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecurringDonationPayload>
        }
        createMany: {
          args: Prisma.RecurringDonationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RecurringDonationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecurringDonationPayload>[]
        }
        delete: {
          args: Prisma.RecurringDonationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecurringDonationPayload>
        }
        update: {
          args: Prisma.RecurringDonationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecurringDonationPayload>
        }
        deleteMany: {
          args: Prisma.RecurringDonationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RecurringDonationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RecurringDonationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecurringDonationPayload>[]
        }
        upsert: {
          args: Prisma.RecurringDonationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecurringDonationPayload>
        }
        aggregate: {
          args: Prisma.RecurringDonationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRecurringDonation>
        }
        groupBy: {
          args: Prisma.RecurringDonationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RecurringDonationGroupByOutputType>[]
        }
        count: {
          args: Prisma.RecurringDonationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RecurringDonationCountAggregateOutputType> | number
        }
      }
    }
    ExpenseCategory: {
      payload: Prisma.$ExpenseCategoryPayload<ExtArgs>
      fields: Prisma.ExpenseCategoryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ExpenseCategoryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ExpenseCategoryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>
        }
        findFirst: {
          args: Prisma.ExpenseCategoryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ExpenseCategoryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>
        }
        findMany: {
          args: Prisma.ExpenseCategoryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>[]
        }
        create: {
          args: Prisma.ExpenseCategoryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>
        }
        createMany: {
          args: Prisma.ExpenseCategoryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ExpenseCategoryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>[]
        }
        delete: {
          args: Prisma.ExpenseCategoryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>
        }
        update: {
          args: Prisma.ExpenseCategoryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>
        }
        deleteMany: {
          args: Prisma.ExpenseCategoryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ExpenseCategoryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ExpenseCategoryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>[]
        }
        upsert: {
          args: Prisma.ExpenseCategoryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>
        }
        aggregate: {
          args: Prisma.ExpenseCategoryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateExpenseCategory>
        }
        groupBy: {
          args: Prisma.ExpenseCategoryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ExpenseCategoryGroupByOutputType>[]
        }
        count: {
          args: Prisma.ExpenseCategoryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ExpenseCategoryCountAggregateOutputType> | number
        }
      }
    }
    Expense: {
      payload: Prisma.$ExpensePayload<ExtArgs>
      fields: Prisma.ExpenseFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ExpenseFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ExpenseFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload>
        }
        findFirst: {
          args: Prisma.ExpenseFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ExpenseFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload>
        }
        findMany: {
          args: Prisma.ExpenseFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload>[]
        }
        create: {
          args: Prisma.ExpenseCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload>
        }
        createMany: {
          args: Prisma.ExpenseCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ExpenseCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload>[]
        }
        delete: {
          args: Prisma.ExpenseDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload>
        }
        update: {
          args: Prisma.ExpenseUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload>
        }
        deleteMany: {
          args: Prisma.ExpenseDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ExpenseUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ExpenseUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload>[]
        }
        upsert: {
          args: Prisma.ExpenseUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload>
        }
        aggregate: {
          args: Prisma.ExpenseAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateExpense>
        }
        groupBy: {
          args: Prisma.ExpenseGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ExpenseGroupByOutputType>[]
        }
        count: {
          args: Prisma.ExpenseCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ExpenseCountAggregateOutputType> | number
        }
      }
    }
    Budget: {
      payload: Prisma.$BudgetPayload<ExtArgs>
      fields: Prisma.BudgetFieldRefs
      operations: {
        findUnique: {
          args: Prisma.BudgetFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BudgetPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.BudgetFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BudgetPayload>
        }
        findFirst: {
          args: Prisma.BudgetFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BudgetPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.BudgetFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BudgetPayload>
        }
        findMany: {
          args: Prisma.BudgetFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BudgetPayload>[]
        }
        create: {
          args: Prisma.BudgetCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BudgetPayload>
        }
        createMany: {
          args: Prisma.BudgetCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.BudgetCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BudgetPayload>[]
        }
        delete: {
          args: Prisma.BudgetDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BudgetPayload>
        }
        update: {
          args: Prisma.BudgetUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BudgetPayload>
        }
        deleteMany: {
          args: Prisma.BudgetDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.BudgetUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.BudgetUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BudgetPayload>[]
        }
        upsert: {
          args: Prisma.BudgetUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BudgetPayload>
        }
        aggregate: {
          args: Prisma.BudgetAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateBudget>
        }
        groupBy: {
          args: Prisma.BudgetGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BudgetGroupByOutputType>[]
        }
        count: {
          args: Prisma.BudgetCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BudgetCountAggregateOutputType> | number
        }
      }
    }
    BudgetItem: {
      payload: Prisma.$BudgetItemPayload<ExtArgs>
      fields: Prisma.BudgetItemFieldRefs
      operations: {
        findUnique: {
          args: Prisma.BudgetItemFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BudgetItemPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.BudgetItemFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BudgetItemPayload>
        }
        findFirst: {
          args: Prisma.BudgetItemFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BudgetItemPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.BudgetItemFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BudgetItemPayload>
        }
        findMany: {
          args: Prisma.BudgetItemFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BudgetItemPayload>[]
        }
        create: {
          args: Prisma.BudgetItemCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BudgetItemPayload>
        }
        createMany: {
          args: Prisma.BudgetItemCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.BudgetItemCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BudgetItemPayload>[]
        }
        delete: {
          args: Prisma.BudgetItemDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BudgetItemPayload>
        }
        update: {
          args: Prisma.BudgetItemUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BudgetItemPayload>
        }
        deleteMany: {
          args: Prisma.BudgetItemDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.BudgetItemUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.BudgetItemUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BudgetItemPayload>[]
        }
        upsert: {
          args: Prisma.BudgetItemUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BudgetItemPayload>
        }
        aggregate: {
          args: Prisma.BudgetItemAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateBudgetItem>
        }
        groupBy: {
          args: Prisma.BudgetItemGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BudgetItemGroupByOutputType>[]
        }
        count: {
          args: Prisma.BudgetItemCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BudgetItemCountAggregateOutputType> | number
        }
      }
    }
    AuditLog: {
      payload: Prisma.$AuditLogPayload<ExtArgs>
      fields: Prisma.AuditLogFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        findFirst: {
          args: Prisma.AuditLogFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        findMany: {
          args: Prisma.AuditLogFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
        }
        create: {
          args: Prisma.AuditLogCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        createMany: {
          args: Prisma.AuditLogCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
        }
        delete: {
          args: Prisma.AuditLogDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        update: {
          args: Prisma.AuditLogUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        deleteMany: {
          args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
        }
        upsert: {
          args: Prisma.AuditLogUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        aggregate: {
          args: Prisma.AuditLogAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAuditLog>
        }
        groupBy: {
          args: Prisma.AuditLogGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AuditLogGroupByOutputType>[]
        }
        count: {
          args: Prisma.AuditLogCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AuditLogCountAggregateOutputType> | number
        }
      }
    }
    User: {
      payload: Prisma.$UserPayload<ExtArgs>
      fields: Prisma.UserFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        findFirst: {
          args: Prisma.UserFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        findMany: {
          args: Prisma.UserFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        create: {
          args: Prisma.UserCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        createMany: {
          args: Prisma.UserCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        delete: {
          args: Prisma.UserDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        update: {
          args: Prisma.UserUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        deleteMany: {
          args: Prisma.UserDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        upsert: {
          args: Prisma.UserUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        aggregate: {
          args: Prisma.UserAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUser>
        }
        groupBy: {
          args: Prisma.UserGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserCountAggregateOutputType> | number
        }
      }
    }
    StaffMembership: {
      payload: Prisma.$StaffMembershipPayload<ExtArgs>
      fields: Prisma.StaffMembershipFieldRefs
      operations: {
        findUnique: {
          args: Prisma.StaffMembershipFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffMembershipPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.StaffMembershipFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffMembershipPayload>
        }
        findFirst: {
          args: Prisma.StaffMembershipFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffMembershipPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.StaffMembershipFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffMembershipPayload>
        }
        findMany: {
          args: Prisma.StaffMembershipFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffMembershipPayload>[]
        }
        create: {
          args: Prisma.StaffMembershipCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffMembershipPayload>
        }
        createMany: {
          args: Prisma.StaffMembershipCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.StaffMembershipCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffMembershipPayload>[]
        }
        delete: {
          args: Prisma.StaffMembershipDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffMembershipPayload>
        }
        update: {
          args: Prisma.StaffMembershipUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffMembershipPayload>
        }
        deleteMany: {
          args: Prisma.StaffMembershipDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.StaffMembershipUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.StaffMembershipUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffMembershipPayload>[]
        }
        upsert: {
          args: Prisma.StaffMembershipUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffMembershipPayload>
        }
        aggregate: {
          args: Prisma.StaffMembershipAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateStaffMembership>
        }
        groupBy: {
          args: Prisma.StaffMembershipGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.StaffMembershipGroupByOutputType>[]
        }
        count: {
          args: Prisma.StaffMembershipCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.StaffMembershipCountAggregateOutputType> | number
        }
      }
    }
    Facility: {
      payload: Prisma.$FacilityPayload<ExtArgs>
      fields: Prisma.FacilityFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FacilityFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FacilityFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityPayload>
        }
        findFirst: {
          args: Prisma.FacilityFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FacilityFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityPayload>
        }
        findMany: {
          args: Prisma.FacilityFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityPayload>[]
        }
        create: {
          args: Prisma.FacilityCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityPayload>
        }
        createMany: {
          args: Prisma.FacilityCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FacilityCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityPayload>[]
        }
        delete: {
          args: Prisma.FacilityDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityPayload>
        }
        update: {
          args: Prisma.FacilityUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityPayload>
        }
        deleteMany: {
          args: Prisma.FacilityDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FacilityUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FacilityUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityPayload>[]
        }
        upsert: {
          args: Prisma.FacilityUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityPayload>
        }
        aggregate: {
          args: Prisma.FacilityAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFacility>
        }
        groupBy: {
          args: Prisma.FacilityGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FacilityGroupByOutputType>[]
        }
        count: {
          args: Prisma.FacilityCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FacilityCountAggregateOutputType> | number
        }
      }
    }
    FacilityBooking: {
      payload: Prisma.$FacilityBookingPayload<ExtArgs>
      fields: Prisma.FacilityBookingFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FacilityBookingFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityBookingPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FacilityBookingFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityBookingPayload>
        }
        findFirst: {
          args: Prisma.FacilityBookingFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityBookingPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FacilityBookingFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityBookingPayload>
        }
        findMany: {
          args: Prisma.FacilityBookingFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityBookingPayload>[]
        }
        create: {
          args: Prisma.FacilityBookingCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityBookingPayload>
        }
        createMany: {
          args: Prisma.FacilityBookingCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FacilityBookingCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityBookingPayload>[]
        }
        delete: {
          args: Prisma.FacilityBookingDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityBookingPayload>
        }
        update: {
          args: Prisma.FacilityBookingUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityBookingPayload>
        }
        deleteMany: {
          args: Prisma.FacilityBookingDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FacilityBookingUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FacilityBookingUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityBookingPayload>[]
        }
        upsert: {
          args: Prisma.FacilityBookingUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityBookingPayload>
        }
        aggregate: {
          args: Prisma.FacilityBookingAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFacilityBooking>
        }
        groupBy: {
          args: Prisma.FacilityBookingGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FacilityBookingGroupByOutputType>[]
        }
        count: {
          args: Prisma.FacilityBookingCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FacilityBookingCountAggregateOutputType> | number
        }
      }
    }
    CareRequest: {
      payload: Prisma.$CareRequestPayload<ExtArgs>
      fields: Prisma.CareRequestFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CareRequestFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareRequestPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CareRequestFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareRequestPayload>
        }
        findFirst: {
          args: Prisma.CareRequestFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareRequestPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CareRequestFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareRequestPayload>
        }
        findMany: {
          args: Prisma.CareRequestFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareRequestPayload>[]
        }
        create: {
          args: Prisma.CareRequestCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareRequestPayload>
        }
        createMany: {
          args: Prisma.CareRequestCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CareRequestCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareRequestPayload>[]
        }
        delete: {
          args: Prisma.CareRequestDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareRequestPayload>
        }
        update: {
          args: Prisma.CareRequestUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareRequestPayload>
        }
        deleteMany: {
          args: Prisma.CareRequestDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CareRequestUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CareRequestUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareRequestPayload>[]
        }
        upsert: {
          args: Prisma.CareRequestUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareRequestPayload>
        }
        aggregate: {
          args: Prisma.CareRequestAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCareRequest>
        }
        groupBy: {
          args: Prisma.CareRequestGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CareRequestGroupByOutputType>[]
        }
        count: {
          args: Prisma.CareRequestCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CareRequestCountAggregateOutputType> | number
        }
      }
    }
    CareNote: {
      payload: Prisma.$CareNotePayload<ExtArgs>
      fields: Prisma.CareNoteFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CareNoteFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareNotePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CareNoteFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareNotePayload>
        }
        findFirst: {
          args: Prisma.CareNoteFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareNotePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CareNoteFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareNotePayload>
        }
        findMany: {
          args: Prisma.CareNoteFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareNotePayload>[]
        }
        create: {
          args: Prisma.CareNoteCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareNotePayload>
        }
        createMany: {
          args: Prisma.CareNoteCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CareNoteCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareNotePayload>[]
        }
        delete: {
          args: Prisma.CareNoteDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareNotePayload>
        }
        update: {
          args: Prisma.CareNoteUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareNotePayload>
        }
        deleteMany: {
          args: Prisma.CareNoteDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CareNoteUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CareNoteUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareNotePayload>[]
        }
        upsert: {
          args: Prisma.CareNoteUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareNotePayload>
        }
        aggregate: {
          args: Prisma.CareNoteAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCareNote>
        }
        groupBy: {
          args: Prisma.CareNoteGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CareNoteGroupByOutputType>[]
        }
        count: {
          args: Prisma.CareNoteCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CareNoteCountAggregateOutputType> | number
        }
      }
    }
    Sermon: {
      payload: Prisma.$SermonPayload<ExtArgs>
      fields: Prisma.SermonFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SermonFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SermonPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SermonFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SermonPayload>
        }
        findFirst: {
          args: Prisma.SermonFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SermonPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SermonFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SermonPayload>
        }
        findMany: {
          args: Prisma.SermonFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SermonPayload>[]
        }
        create: {
          args: Prisma.SermonCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SermonPayload>
        }
        createMany: {
          args: Prisma.SermonCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SermonCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SermonPayload>[]
        }
        delete: {
          args: Prisma.SermonDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SermonPayload>
        }
        update: {
          args: Prisma.SermonUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SermonPayload>
        }
        deleteMany: {
          args: Prisma.SermonDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SermonUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SermonUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SermonPayload>[]
        }
        upsert: {
          args: Prisma.SermonUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SermonPayload>
        }
        aggregate: {
          args: Prisma.SermonAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSermon>
        }
        groupBy: {
          args: Prisma.SermonGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SermonGroupByOutputType>[]
        }
        count: {
          args: Prisma.SermonCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SermonCountAggregateOutputType> | number
        }
      }
    }
    ContentResource: {
      payload: Prisma.$ContentResourcePayload<ExtArgs>
      fields: Prisma.ContentResourceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ContentResourceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContentResourcePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ContentResourceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContentResourcePayload>
        }
        findFirst: {
          args: Prisma.ContentResourceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContentResourcePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ContentResourceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContentResourcePayload>
        }
        findMany: {
          args: Prisma.ContentResourceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContentResourcePayload>[]
        }
        create: {
          args: Prisma.ContentResourceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContentResourcePayload>
        }
        createMany: {
          args: Prisma.ContentResourceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ContentResourceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContentResourcePayload>[]
        }
        delete: {
          args: Prisma.ContentResourceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContentResourcePayload>
        }
        update: {
          args: Prisma.ContentResourceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContentResourcePayload>
        }
        deleteMany: {
          args: Prisma.ContentResourceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ContentResourceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ContentResourceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContentResourcePayload>[]
        }
        upsert: {
          args: Prisma.ContentResourceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContentResourcePayload>
        }
        aggregate: {
          args: Prisma.ContentResourceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateContentResource>
        }
        groupBy: {
          args: Prisma.ContentResourceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ContentResourceGroupByOutputType>[]
        }
        count: {
          args: Prisma.ContentResourceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ContentResourceCountAggregateOutputType> | number
        }
      }
    }
    TenantDomain: {
      payload: Prisma.$TenantDomainPayload<ExtArgs>
      fields: Prisma.TenantDomainFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TenantDomainFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantDomainPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TenantDomainFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantDomainPayload>
        }
        findFirst: {
          args: Prisma.TenantDomainFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantDomainPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TenantDomainFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantDomainPayload>
        }
        findMany: {
          args: Prisma.TenantDomainFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantDomainPayload>[]
        }
        create: {
          args: Prisma.TenantDomainCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantDomainPayload>
        }
        createMany: {
          args: Prisma.TenantDomainCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TenantDomainCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantDomainPayload>[]
        }
        delete: {
          args: Prisma.TenantDomainDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantDomainPayload>
        }
        update: {
          args: Prisma.TenantDomainUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantDomainPayload>
        }
        deleteMany: {
          args: Prisma.TenantDomainDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TenantDomainUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TenantDomainUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantDomainPayload>[]
        }
        upsert: {
          args: Prisma.TenantDomainUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantDomainPayload>
        }
        aggregate: {
          args: Prisma.TenantDomainAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTenantDomain>
        }
        groupBy: {
          args: Prisma.TenantDomainGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantDomainGroupByOutputType>[]
        }
        count: {
          args: Prisma.TenantDomainCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantDomainCountAggregateOutputType> | number
        }
      }
    }
    TenantHealthCheck: {
      payload: Prisma.$TenantHealthCheckPayload<ExtArgs>
      fields: Prisma.TenantHealthCheckFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TenantHealthCheckFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantHealthCheckPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TenantHealthCheckFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantHealthCheckPayload>
        }
        findFirst: {
          args: Prisma.TenantHealthCheckFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantHealthCheckPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TenantHealthCheckFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantHealthCheckPayload>
        }
        findMany: {
          args: Prisma.TenantHealthCheckFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantHealthCheckPayload>[]
        }
        create: {
          args: Prisma.TenantHealthCheckCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantHealthCheckPayload>
        }
        createMany: {
          args: Prisma.TenantHealthCheckCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TenantHealthCheckCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantHealthCheckPayload>[]
        }
        delete: {
          args: Prisma.TenantHealthCheckDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantHealthCheckPayload>
        }
        update: {
          args: Prisma.TenantHealthCheckUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantHealthCheckPayload>
        }
        deleteMany: {
          args: Prisma.TenantHealthCheckDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TenantHealthCheckUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TenantHealthCheckUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantHealthCheckPayload>[]
        }
        upsert: {
          args: Prisma.TenantHealthCheckUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantHealthCheckPayload>
        }
        aggregate: {
          args: Prisma.TenantHealthCheckAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTenantHealthCheck>
        }
        groupBy: {
          args: Prisma.TenantHealthCheckGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantHealthCheckGroupByOutputType>[]
        }
        count: {
          args: Prisma.TenantHealthCheckCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantHealthCheckCountAggregateOutputType> | number
        }
      }
    }
    TenantSecurityPolicy: {
      payload: Prisma.$TenantSecurityPolicyPayload<ExtArgs>
      fields: Prisma.TenantSecurityPolicyFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TenantSecurityPolicyFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantSecurityPolicyPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TenantSecurityPolicyFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantSecurityPolicyPayload>
        }
        findFirst: {
          args: Prisma.TenantSecurityPolicyFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantSecurityPolicyPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TenantSecurityPolicyFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantSecurityPolicyPayload>
        }
        findMany: {
          args: Prisma.TenantSecurityPolicyFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantSecurityPolicyPayload>[]
        }
        create: {
          args: Prisma.TenantSecurityPolicyCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantSecurityPolicyPayload>
        }
        createMany: {
          args: Prisma.TenantSecurityPolicyCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TenantSecurityPolicyCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantSecurityPolicyPayload>[]
        }
        delete: {
          args: Prisma.TenantSecurityPolicyDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantSecurityPolicyPayload>
        }
        update: {
          args: Prisma.TenantSecurityPolicyUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantSecurityPolicyPayload>
        }
        deleteMany: {
          args: Prisma.TenantSecurityPolicyDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TenantSecurityPolicyUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TenantSecurityPolicyUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantSecurityPolicyPayload>[]
        }
        upsert: {
          args: Prisma.TenantSecurityPolicyUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantSecurityPolicyPayload>
        }
        aggregate: {
          args: Prisma.TenantSecurityPolicyAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTenantSecurityPolicy>
        }
        groupBy: {
          args: Prisma.TenantSecurityPolicyGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantSecurityPolicyGroupByOutputType>[]
        }
        count: {
          args: Prisma.TenantSecurityPolicyCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantSecurityPolicyCountAggregateOutputType> | number
        }
      }
    }
    SupportTicket: {
      payload: Prisma.$SupportTicketPayload<ExtArgs>
      fields: Prisma.SupportTicketFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SupportTicketFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupportTicketPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SupportTicketFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupportTicketPayload>
        }
        findFirst: {
          args: Prisma.SupportTicketFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupportTicketPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SupportTicketFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupportTicketPayload>
        }
        findMany: {
          args: Prisma.SupportTicketFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupportTicketPayload>[]
        }
        create: {
          args: Prisma.SupportTicketCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupportTicketPayload>
        }
        createMany: {
          args: Prisma.SupportTicketCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SupportTicketCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupportTicketPayload>[]
        }
        delete: {
          args: Prisma.SupportTicketDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupportTicketPayload>
        }
        update: {
          args: Prisma.SupportTicketUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupportTicketPayload>
        }
        deleteMany: {
          args: Prisma.SupportTicketDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SupportTicketUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SupportTicketUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupportTicketPayload>[]
        }
        upsert: {
          args: Prisma.SupportTicketUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupportTicketPayload>
        }
        aggregate: {
          args: Prisma.SupportTicketAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSupportTicket>
        }
        groupBy: {
          args: Prisma.SupportTicketGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SupportTicketGroupByOutputType>[]
        }
        count: {
          args: Prisma.SupportTicketCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SupportTicketCountAggregateOutputType> | number
        }
      }
    }
    SupportTicketMessage: {
      payload: Prisma.$SupportTicketMessagePayload<ExtArgs>
      fields: Prisma.SupportTicketMessageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SupportTicketMessageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupportTicketMessagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SupportTicketMessageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupportTicketMessagePayload>
        }
        findFirst: {
          args: Prisma.SupportTicketMessageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupportTicketMessagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SupportTicketMessageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupportTicketMessagePayload>
        }
        findMany: {
          args: Prisma.SupportTicketMessageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupportTicketMessagePayload>[]
        }
        create: {
          args: Prisma.SupportTicketMessageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupportTicketMessagePayload>
        }
        createMany: {
          args: Prisma.SupportTicketMessageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SupportTicketMessageCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupportTicketMessagePayload>[]
        }
        delete: {
          args: Prisma.SupportTicketMessageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupportTicketMessagePayload>
        }
        update: {
          args: Prisma.SupportTicketMessageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupportTicketMessagePayload>
        }
        deleteMany: {
          args: Prisma.SupportTicketMessageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SupportTicketMessageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SupportTicketMessageUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupportTicketMessagePayload>[]
        }
        upsert: {
          args: Prisma.SupportTicketMessageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupportTicketMessagePayload>
        }
        aggregate: {
          args: Prisma.SupportTicketMessageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSupportTicketMessage>
        }
        groupBy: {
          args: Prisma.SupportTicketMessageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SupportTicketMessageGroupByOutputType>[]
        }
        count: {
          args: Prisma.SupportTicketMessageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SupportTicketMessageCountAggregateOutputType> | number
        }
      }
    }
    WebhookEvent: {
      payload: Prisma.$WebhookEventPayload<ExtArgs>
      fields: Prisma.WebhookEventFieldRefs
      operations: {
        findUnique: {
          args: Prisma.WebhookEventFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookEventPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.WebhookEventFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookEventPayload>
        }
        findFirst: {
          args: Prisma.WebhookEventFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookEventPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.WebhookEventFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookEventPayload>
        }
        findMany: {
          args: Prisma.WebhookEventFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookEventPayload>[]
        }
        create: {
          args: Prisma.WebhookEventCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookEventPayload>
        }
        createMany: {
          args: Prisma.WebhookEventCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.WebhookEventCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookEventPayload>[]
        }
        delete: {
          args: Prisma.WebhookEventDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookEventPayload>
        }
        update: {
          args: Prisma.WebhookEventUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookEventPayload>
        }
        deleteMany: {
          args: Prisma.WebhookEventDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.WebhookEventUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.WebhookEventUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookEventPayload>[]
        }
        upsert: {
          args: Prisma.WebhookEventUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookEventPayload>
        }
        aggregate: {
          args: Prisma.WebhookEventAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateWebhookEvent>
        }
        groupBy: {
          args: Prisma.WebhookEventGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WebhookEventGroupByOutputType>[]
        }
        count: {
          args: Prisma.WebhookEventCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WebhookEventCountAggregateOutputType> | number
        }
      }
    }
    LiveStreamChannel: {
      payload: Prisma.$LiveStreamChannelPayload<ExtArgs>
      fields: Prisma.LiveStreamChannelFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LiveStreamChannelFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiveStreamChannelPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LiveStreamChannelFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiveStreamChannelPayload>
        }
        findFirst: {
          args: Prisma.LiveStreamChannelFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiveStreamChannelPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LiveStreamChannelFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiveStreamChannelPayload>
        }
        findMany: {
          args: Prisma.LiveStreamChannelFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiveStreamChannelPayload>[]
        }
        create: {
          args: Prisma.LiveStreamChannelCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiveStreamChannelPayload>
        }
        createMany: {
          args: Prisma.LiveStreamChannelCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LiveStreamChannelCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiveStreamChannelPayload>[]
        }
        delete: {
          args: Prisma.LiveStreamChannelDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiveStreamChannelPayload>
        }
        update: {
          args: Prisma.LiveStreamChannelUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiveStreamChannelPayload>
        }
        deleteMany: {
          args: Prisma.LiveStreamChannelDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LiveStreamChannelUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LiveStreamChannelUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiveStreamChannelPayload>[]
        }
        upsert: {
          args: Prisma.LiveStreamChannelUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiveStreamChannelPayload>
        }
        aggregate: {
          args: Prisma.LiveStreamChannelAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLiveStreamChannel>
        }
        groupBy: {
          args: Prisma.LiveStreamChannelGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LiveStreamChannelGroupByOutputType>[]
        }
        count: {
          args: Prisma.LiveStreamChannelCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LiveStreamChannelCountAggregateOutputType> | number
        }
      }
    }
    LiveStreamSession: {
      payload: Prisma.$LiveStreamSessionPayload<ExtArgs>
      fields: Prisma.LiveStreamSessionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LiveStreamSessionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiveStreamSessionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LiveStreamSessionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiveStreamSessionPayload>
        }
        findFirst: {
          args: Prisma.LiveStreamSessionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiveStreamSessionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LiveStreamSessionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiveStreamSessionPayload>
        }
        findMany: {
          args: Prisma.LiveStreamSessionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiveStreamSessionPayload>[]
        }
        create: {
          args: Prisma.LiveStreamSessionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiveStreamSessionPayload>
        }
        createMany: {
          args: Prisma.LiveStreamSessionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LiveStreamSessionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiveStreamSessionPayload>[]
        }
        delete: {
          args: Prisma.LiveStreamSessionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiveStreamSessionPayload>
        }
        update: {
          args: Prisma.LiveStreamSessionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiveStreamSessionPayload>
        }
        deleteMany: {
          args: Prisma.LiveStreamSessionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LiveStreamSessionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LiveStreamSessionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiveStreamSessionPayload>[]
        }
        upsert: {
          args: Prisma.LiveStreamSessionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LiveStreamSessionPayload>
        }
        aggregate: {
          args: Prisma.LiveStreamSessionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLiveStreamSession>
        }
        groupBy: {
          args: Prisma.LiveStreamSessionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LiveStreamSessionGroupByOutputType>[]
        }
        count: {
          args: Prisma.LiveStreamSessionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LiveStreamSessionCountAggregateOutputType> | number
        }
      }
    }
  }
} & {
  other: {
    payload: any
    operations: {
      $executeRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $executeRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
      $queryRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $queryRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
    }
  }
}

/**
 * Enums
 */

export const TransactionIsolationLevel = runtime.makeStrictEnum({
  ReadUncommitted: 'ReadUncommitted',
  ReadCommitted: 'ReadCommitted',
  RepeatableRead: 'RepeatableRead',
  Serializable: 'Serializable'
} as const)

export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


export const TenantScalarFieldEnum = {
  id: 'id',
  name: 'name',
  slug: 'slug',
  clerkOrgId: 'clerkOrgId',
  status: 'status',
  suspendedAt: 'suspendedAt',
  suspensionReason: 'suspensionReason',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type TenantScalarFieldEnum = (typeof TenantScalarFieldEnum)[keyof typeof TenantScalarFieldEnum]


export const OrganizationScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  name: 'name',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type OrganizationScalarFieldEnum = (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum]


export const ChurchScalarFieldEnum = {
  id: 'id',
  organizationId: 'organizationId',
  name: 'name',
  slug: 'slug',
  countryCode: 'countryCode',
  timezone: 'timezone',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ChurchScalarFieldEnum = (typeof ChurchScalarFieldEnum)[keyof typeof ChurchScalarFieldEnum]


export const CampusScalarFieldEnum = {
  id: 'id',
  churchId: 'churchId',
  name: 'name',
  timezone: 'timezone',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CampusScalarFieldEnum = (typeof CampusScalarFieldEnum)[keyof typeof CampusScalarFieldEnum]


export const HouseholdScalarFieldEnum = {
  id: 'id',
  churchId: 'churchId',
  name: 'name',
  primaryMemberId: 'primaryMemberId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type HouseholdScalarFieldEnum = (typeof HouseholdScalarFieldEnum)[keyof typeof HouseholdScalarFieldEnum]


export const MemberScalarFieldEnum = {
  id: 'id',
  churchId: 'churchId',
  householdId: 'householdId',
  firstName: 'firstName',
  middleName: 'middleName',
  lastName: 'lastName',
  preferredName: 'preferredName',
  email: 'email',
  clerkUserId: 'clerkUserId',
  phone: 'phone',
  status: 'status',
  gender: 'gender',
  maritalStatus: 'maritalStatus',
  directoryVisibility: 'directoryVisibility',
  showEmailInDirectory: 'showEmailInDirectory',
  showPhoneInDirectory: 'showPhoneInDirectory',
  showAddressInDirectory: 'showAddressInDirectory',
  showPhotoInDirectory: 'showPhotoInDirectory',
  dateOfBirth: 'dateOfBirth',
  joinDate: 'joinDate',
  baptismDate: 'baptismDate',
  confirmationDate: 'confirmationDate',
  avatarUrl: 'avatarUrl',
  addressLine1: 'addressLine1',
  addressLine2: 'addressLine2',
  city: 'city',
  state: 'state',
  postalCode: 'postalCode',
  country: 'country',
  emergencyContactName: 'emergencyContactName',
  emergencyContactPhone: 'emergencyContactPhone',
  notes: 'notes',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type MemberScalarFieldEnum = (typeof MemberScalarFieldEnum)[keyof typeof MemberScalarFieldEnum]


export const MemberAccessRequestScalarFieldEnum = {
  id: 'id',
  churchId: 'churchId',
  clerkUserId: 'clerkUserId',
  email: 'email',
  name: 'name',
  message: 'message',
  status: 'status',
  memberId: 'memberId',
  approvedAt: 'approvedAt',
  deniedAt: 'deniedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type MemberAccessRequestScalarFieldEnum = (typeof MemberAccessRequestScalarFieldEnum)[keyof typeof MemberAccessRequestScalarFieldEnum]


export const StaffInviteScalarFieldEnum = {
  id: 'id',
  churchId: 'churchId',
  email: 'email',
  clerkUserId: 'clerkUserId',
  role: 'role',
  invitedByClerkUserId: 'invitedByClerkUserId',
  clerkInvitationId: 'clerkInvitationId',
  status: 'status',
  acceptedAt: 'acceptedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type StaffInviteScalarFieldEnum = (typeof StaffInviteScalarFieldEnum)[keyof typeof StaffInviteScalarFieldEnum]


export const PlatformUserScalarFieldEnum = {
  id: 'id',
  clerkUserId: 'clerkUserId',
  email: 'email',
  name: 'name',
  status: 'status',
  mfaEnabled: 'mfaEnabled',
  lastAccessAt: 'lastAccessAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PlatformUserScalarFieldEnum = (typeof PlatformUserScalarFieldEnum)[keyof typeof PlatformUserScalarFieldEnum]


export const PlatformUserRoleScalarFieldEnum = {
  id: 'id',
  platformUserId: 'platformUserId',
  role: 'role',
  createdAt: 'createdAt'
} as const

export type PlatformUserRoleScalarFieldEnum = (typeof PlatformUserRoleScalarFieldEnum)[keyof typeof PlatformUserRoleScalarFieldEnum]


export const SubscriptionPlanScalarFieldEnum = {
  id: 'id',
  code: 'code',
  name: 'name',
  description: 'description',
  currency: 'currency',
  interval: 'interval',
  amountMinor: 'amountMinor',
  isActive: 'isActive',
  isDefault: 'isDefault',
  metadata: 'metadata',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type SubscriptionPlanScalarFieldEnum = (typeof SubscriptionPlanScalarFieldEnum)[keyof typeof SubscriptionPlanScalarFieldEnum]


export const SubscriptionPlanFeatureScalarFieldEnum = {
  id: 'id',
  planId: 'planId',
  key: 'key',
  enabled: 'enabled',
  limit: 'limit',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type SubscriptionPlanFeatureScalarFieldEnum = (typeof SubscriptionPlanFeatureScalarFieldEnum)[keyof typeof SubscriptionPlanFeatureScalarFieldEnum]


export const TenantSubscriptionScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  planId: 'planId',
  status: 'status',
  provider: 'provider',
  providerRef: 'providerRef',
  startsAt: 'startsAt',
  currentPeriodStart: 'currentPeriodStart',
  currentPeriodEnd: 'currentPeriodEnd',
  trialEndsAt: 'trialEndsAt',
  canceledAt: 'canceledAt',
  cancelAtPeriodEnd: 'cancelAtPeriodEnd',
  seatCount: 'seatCount',
  metadata: 'metadata',
  createdByPlatformUserId: 'createdByPlatformUserId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type TenantSubscriptionScalarFieldEnum = (typeof TenantSubscriptionScalarFieldEnum)[keyof typeof TenantSubscriptionScalarFieldEnum]


export const ImportBatchScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  churchId: 'churchId',
  entityType: 'entityType',
  status: 'status',
  filename: 'filename',
  rowCount: 'rowCount',
  createdByClerkUserId: 'createdByClerkUserId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ImportBatchScalarFieldEnum = (typeof ImportBatchScalarFieldEnum)[keyof typeof ImportBatchScalarFieldEnum]


export const ImportBatchItemScalarFieldEnum = {
  id: 'id',
  batchId: 'batchId',
  entityType: 'entityType',
  action: 'action',
  entityId: 'entityId',
  metadata: 'metadata',
  createdAt: 'createdAt'
} as const

export type ImportBatchItemScalarFieldEnum = (typeof ImportBatchItemScalarFieldEnum)[keyof typeof ImportBatchItemScalarFieldEnum]


export const MemberRegistrationScalarFieldEnum = {
  id: 'id',
  churchId: 'churchId',
  memberId: 'memberId',
  email: 'email',
  tokenHash: 'tokenHash',
  status: 'status',
  expiresAt: 'expiresAt',
  createdAt: 'createdAt',
  verifiedAt: 'verifiedAt'
} as const

export type MemberRegistrationScalarFieldEnum = (typeof MemberRegistrationScalarFieldEnum)[keyof typeof MemberRegistrationScalarFieldEnum]


export const MemberTagScalarFieldEnum = {
  id: 'id',
  churchId: 'churchId',
  name: 'name',
  color: 'color',
  description: 'description',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type MemberTagScalarFieldEnum = (typeof MemberTagScalarFieldEnum)[keyof typeof MemberTagScalarFieldEnum]


export const MemberTagAssignmentScalarFieldEnum = {
  id: 'id',
  memberId: 'memberId',
  tagId: 'tagId',
  createdAt: 'createdAt'
} as const

export type MemberTagAssignmentScalarFieldEnum = (typeof MemberTagAssignmentScalarFieldEnum)[keyof typeof MemberTagAssignmentScalarFieldEnum]


export const MemberMilestoneScalarFieldEnum = {
  id: 'id',
  memberId: 'memberId',
  type: 'type',
  date: 'date',
  notes: 'notes',
  createdAt: 'createdAt'
} as const

export type MemberMilestoneScalarFieldEnum = (typeof MemberMilestoneScalarFieldEnum)[keyof typeof MemberMilestoneScalarFieldEnum]


export const GroupScalarFieldEnum = {
  id: 'id',
  churchId: 'churchId',
  name: 'name',
  type: 'type',
  status: 'status',
  description: 'description',
  location: 'location',
  meetingSchedule: 'meetingSchedule',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type GroupScalarFieldEnum = (typeof GroupScalarFieldEnum)[keyof typeof GroupScalarFieldEnum]


export const OnboardingWorkflowScalarFieldEnum = {
  id: 'id',
  churchId: 'churchId',
  name: 'name',
  status: 'status',
  description: 'description',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type OnboardingWorkflowScalarFieldEnum = (typeof OnboardingWorkflowScalarFieldEnum)[keyof typeof OnboardingWorkflowScalarFieldEnum]


export const OnboardingStepScalarFieldEnum = {
  id: 'id',
  workflowId: 'workflowId',
  name: 'name',
  type: 'type',
  order: 'order',
  description: 'description',
  dueDays: 'dueDays',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type OnboardingStepScalarFieldEnum = (typeof OnboardingStepScalarFieldEnum)[keyof typeof OnboardingStepScalarFieldEnum]


export const MemberOnboardingScalarFieldEnum = {
  id: 'id',
  memberId: 'memberId',
  workflowId: 'workflowId',
  status: 'status',
  startedAt: 'startedAt',
  completedAt: 'completedAt'
} as const

export type MemberOnboardingScalarFieldEnum = (typeof MemberOnboardingScalarFieldEnum)[keyof typeof MemberOnboardingScalarFieldEnum]


export const MemberOnboardingTaskScalarFieldEnum = {
  id: 'id',
  onboardingId: 'onboardingId',
  stepId: 'stepId',
  status: 'status',
  dueDate: 'dueDate',
  completedAt: 'completedAt',
  notes: 'notes'
} as const

export type MemberOnboardingTaskScalarFieldEnum = (typeof MemberOnboardingTaskScalarFieldEnum)[keyof typeof MemberOnboardingTaskScalarFieldEnum]


export const GroupMemberScalarFieldEnum = {
  id: 'id',
  groupId: 'groupId',
  memberId: 'memberId',
  role: 'role',
  joinedAt: 'joinedAt'
} as const

export type GroupMemberScalarFieldEnum = (typeof GroupMemberScalarFieldEnum)[keyof typeof GroupMemberScalarFieldEnum]


export const VolunteerRoleScalarFieldEnum = {
  id: 'id',
  churchId: 'churchId',
  name: 'name',
  description: 'description',
  status: 'status',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type VolunteerRoleScalarFieldEnum = (typeof VolunteerRoleScalarFieldEnum)[keyof typeof VolunteerRoleScalarFieldEnum]


export const VolunteerShiftScalarFieldEnum = {
  id: 'id',
  churchId: 'churchId',
  roleId: 'roleId',
  title: 'title',
  description: 'description',
  startAt: 'startAt',
  endAt: 'endAt',
  capacity: 'capacity',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type VolunteerShiftScalarFieldEnum = (typeof VolunteerShiftScalarFieldEnum)[keyof typeof VolunteerShiftScalarFieldEnum]


export const VolunteerShiftAssignmentScalarFieldEnum = {
  id: 'id',
  shiftId: 'shiftId',
  memberId: 'memberId',
  status: 'status',
  assignedAt: 'assignedAt',
  lastReminderAt: 'lastReminderAt',
  notes: 'notes'
} as const

export type VolunteerShiftAssignmentScalarFieldEnum = (typeof VolunteerShiftAssignmentScalarFieldEnum)[keyof typeof VolunteerShiftAssignmentScalarFieldEnum]


export const VolunteerAvailabilityScalarFieldEnum = {
  id: 'id',
  churchId: 'churchId',
  memberId: 'memberId',
  roleId: 'roleId',
  dayOfWeek: 'dayOfWeek',
  startTime: 'startTime',
  endTime: 'endTime',
  timezone: 'timezone',
  notes: 'notes',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type VolunteerAvailabilityScalarFieldEnum = (typeof VolunteerAvailabilityScalarFieldEnum)[keyof typeof VolunteerAvailabilityScalarFieldEnum]


export const SurveyScalarFieldEnum = {
  id: 'id',
  churchId: 'churchId',
  title: 'title',
  description: 'description',
  status: 'status',
  startAt: 'startAt',
  endAt: 'endAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type SurveyScalarFieldEnum = (typeof SurveyScalarFieldEnum)[keyof typeof SurveyScalarFieldEnum]


export const SurveyQuestionScalarFieldEnum = {
  id: 'id',
  surveyId: 'surveyId',
  prompt: 'prompt',
  type: 'type',
  order: 'order',
  required: 'required',
  options: 'options',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type SurveyQuestionScalarFieldEnum = (typeof SurveyQuestionScalarFieldEnum)[keyof typeof SurveyQuestionScalarFieldEnum]


export const SurveyResponseScalarFieldEnum = {
  id: 'id',
  surveyId: 'surveyId',
  memberId: 'memberId',
  respondentName: 'respondentName',
  respondentEmail: 'respondentEmail',
  respondentPhone: 'respondentPhone',
  answers: 'answers',
  createdAt: 'createdAt'
} as const

export type SurveyResponseScalarFieldEnum = (typeof SurveyResponseScalarFieldEnum)[keyof typeof SurveyResponseScalarFieldEnum]


export const VolunteerAssignmentScalarFieldEnum = {
  id: 'id',
  roleId: 'roleId',
  memberId: 'memberId',
  status: 'status',
  assignedAt: 'assignedAt',
  notes: 'notes'
} as const

export type VolunteerAssignmentScalarFieldEnum = (typeof VolunteerAssignmentScalarFieldEnum)[keyof typeof VolunteerAssignmentScalarFieldEnum]


export const EventScalarFieldEnum = {
  id: 'id',
  churchId: 'churchId',
  campusId: 'campusId',
  groupId: 'groupId',
  eventSeriesId: 'eventSeriesId',
  title: 'title',
  description: 'description',
  type: 'type',
  format: 'format',
  visibility: 'visibility',
  startAt: 'startAt',
  endAt: 'endAt',
  location: 'location',
  meetingUrl: 'meetingUrl',
  coverImageUrl: 'coverImageUrl',
  capacity: 'capacity',
  requiresRsvp: 'requiresRsvp',
  registrationEnabled: 'registrationEnabled',
  registrationLimit: 'registrationLimit',
  waitlistEnabled: 'waitlistEnabled',
  registrationFields: 'registrationFields',
  allowGuestRegistration: 'allowGuestRegistration',
  checkInEnabled: 'checkInEnabled',
  checkInCode: 'checkInCode',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type EventScalarFieldEnum = (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum]


export const EventSeriesScalarFieldEnum = {
  id: 'id',
  churchId: 'churchId',
  campusId: 'campusId',
  groupId: 'groupId',
  title: 'title',
  description: 'description',
  type: 'type',
  format: 'format',
  visibility: 'visibility',
  location: 'location',
  meetingUrl: 'meetingUrl',
  coverImageUrl: 'coverImageUrl',
  startDate: 'startDate',
  endDate: 'endDate',
  startTime: 'startTime',
  endTime: 'endTime',
  timezone: 'timezone',
  frequency: 'frequency',
  interval: 'interval',
  weekdays: 'weekdays',
  dayOfMonth: 'dayOfMonth',
  requiresRsvp: 'requiresRsvp',
  registrationEnabled: 'registrationEnabled',
  registrationLimit: 'registrationLimit',
  waitlistEnabled: 'waitlistEnabled',
  registrationFields: 'registrationFields',
  allowGuestRegistration: 'allowGuestRegistration',
  capacity: 'capacity',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type EventSeriesScalarFieldEnum = (typeof EventSeriesScalarFieldEnum)[keyof typeof EventSeriesScalarFieldEnum]


export const EventRsvpScalarFieldEnum = {
  id: 'id',
  eventId: 'eventId',
  memberId: 'memberId',
  status: 'status',
  guestCount: 'guestCount',
  notes: 'notes',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type EventRsvpScalarFieldEnum = (typeof EventRsvpScalarFieldEnum)[keyof typeof EventRsvpScalarFieldEnum]


export const EventBadgeScalarFieldEnum = {
  id: 'id',
  eventId: 'eventId',
  memberId: 'memberId',
  registrationId: 'registrationId',
  ticketOrderId: 'ticketOrderId',
  badgeCode: 'badgeCode',
  sequence: 'sequence',
  status: 'status',
  issuedAt: 'issuedAt',
  usedAt: 'usedAt'
} as const

export type EventBadgeScalarFieldEnum = (typeof EventBadgeScalarFieldEnum)[keyof typeof EventBadgeScalarFieldEnum]


export const EventRegistrationScalarFieldEnum = {
  id: 'id',
  eventId: 'eventId',
  memberId: 'memberId',
  status: 'status',
  guestName: 'guestName',
  guestEmail: 'guestEmail',
  guestPhone: 'guestPhone',
  responses: 'responses',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type EventRegistrationScalarFieldEnum = (typeof EventRegistrationScalarFieldEnum)[keyof typeof EventRegistrationScalarFieldEnum]


export const EventAssignmentScalarFieldEnum = {
  id: 'id',
  eventId: 'eventId',
  memberId: 'memberId',
  role: 'role',
  displayName: 'displayName',
  notes: 'notes',
  createdAt: 'createdAt'
} as const

export type EventAssignmentScalarFieldEnum = (typeof EventAssignmentScalarFieldEnum)[keyof typeof EventAssignmentScalarFieldEnum]


export const EventMediaScalarFieldEnum = {
  id: 'id',
  churchId: 'churchId',
  eventId: 'eventId',
  assetId: 'assetId',
  type: 'type',
  title: 'title',
  description: 'description',
  isPublic: 'isPublic',
  createdAt: 'createdAt'
} as const

export type EventMediaScalarFieldEnum = (typeof EventMediaScalarFieldEnum)[keyof typeof EventMediaScalarFieldEnum]


export const EventTicketTypeScalarFieldEnum = {
  id: 'id',
  eventId: 'eventId',
  name: 'name',
  price: 'price',
  currency: 'currency',
  capacity: 'capacity',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type EventTicketTypeScalarFieldEnum = (typeof EventTicketTypeScalarFieldEnum)[keyof typeof EventTicketTypeScalarFieldEnum]


export const EventTicketOrderScalarFieldEnum = {
  id: 'id',
  eventId: 'eventId',
  ticketTypeId: 'ticketTypeId',
  memberId: 'memberId',
  quantity: 'quantity',
  amount: 'amount',
  currency: 'currency',
  provider: 'provider',
  providerRef: 'providerRef',
  paymentIntentId: 'paymentIntentId',
  status: 'status',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type EventTicketOrderScalarFieldEnum = (typeof EventTicketOrderScalarFieldEnum)[keyof typeof EventTicketOrderScalarFieldEnum]


export const ConversationScalarFieldEnum = {
  id: 'id',
  churchId: 'churchId',
  type: 'type',
  name: 'name',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ConversationScalarFieldEnum = (typeof ConversationScalarFieldEnum)[keyof typeof ConversationScalarFieldEnum]


export const ConversationMemberScalarFieldEnum = {
  id: 'id',
  conversationId: 'conversationId',
  memberId: 'memberId',
  role: 'role',
  joinedAt: 'joinedAt',
  lastReadAt: 'lastReadAt',
  typingAt: 'typingAt',
  muted: 'muted'
} as const

export type ConversationMemberScalarFieldEnum = (typeof ConversationMemberScalarFieldEnum)[keyof typeof ConversationMemberScalarFieldEnum]


export const MessageScalarFieldEnum = {
  id: 'id',
  conversationId: 'conversationId',
  senderType: 'senderType',
  senderMemberId: 'senderMemberId',
  senderUserId: 'senderUserId',
  body: 'body',
  attachments: 'attachments',
  createdAt: 'createdAt'
} as const

export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


export const MediaAssetScalarFieldEnum = {
  id: 'id',
  churchId: 'churchId',
  uploaderMemberId: 'uploaderMemberId',
  uploaderUserId: 'uploaderUserId',
  provider: 'provider',
  bucket: 'bucket',
  key: 'key',
  url: 'url',
  filename: 'filename',
  contentType: 'contentType',
  size: 'size',
  createdAt: 'createdAt'
} as const

export type MediaAssetScalarFieldEnum = (typeof MediaAssetScalarFieldEnum)[keyof typeof MediaAssetScalarFieldEnum]


export const NotificationPreferenceScalarFieldEnum = {
  id: 'id',
  memberId: 'memberId',
  channel: 'channel',
  enabled: 'enabled',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type NotificationPreferenceScalarFieldEnum = (typeof NotificationPreferenceScalarFieldEnum)[keyof typeof NotificationPreferenceScalarFieldEnum]


export const InAppNotificationScalarFieldEnum = {
  id: 'id',
  churchId: 'churchId',
  memberId: 'memberId',
  category: 'category',
  title: 'title',
  body: 'body',
  data: 'data',
  readAt: 'readAt',
  createdAt: 'createdAt'
} as const

export type InAppNotificationScalarFieldEnum = (typeof InAppNotificationScalarFieldEnum)[keyof typeof InAppNotificationScalarFieldEnum]


export const DeviceTokenScalarFieldEnum = {
  id: 'id',
  memberId: 'memberId',
  platform: 'platform',
  provider: 'provider',
  token: 'token',
  lastSeenAt: 'lastSeenAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type DeviceTokenScalarFieldEnum = (typeof DeviceTokenScalarFieldEnum)[keyof typeof DeviceTokenScalarFieldEnum]


export const AttendanceScalarFieldEnum = {
  id: 'id',
  eventId: 'eventId',
  memberId: 'memberId',
  status: 'status',
  checkInAt: 'checkInAt',
  checkOutAt: 'checkOutAt',
  createdAt: 'createdAt'
} as const

export type AttendanceScalarFieldEnum = (typeof AttendanceScalarFieldEnum)[keyof typeof AttendanceScalarFieldEnum]


export const MemberRelationshipScalarFieldEnum = {
  id: 'id',
  churchId: 'churchId',
  fromMemberId: 'fromMemberId',
  toMemberId: 'toMemberId',
  type: 'type',
  label: 'label',
  notes: 'notes',
  createdAt: 'createdAt'
} as const

export type MemberRelationshipScalarFieldEnum = (typeof MemberRelationshipScalarFieldEnum)[keyof typeof MemberRelationshipScalarFieldEnum]


export const DonationScalarFieldEnum = {
  id: 'id',
  churchId: 'churchId',
  memberId: 'memberId',
  fundId: 'fundId',
  campaignId: 'campaignId',
  fundraiserPageId: 'fundraiserPageId',
  paymentIntentId: 'paymentIntentId',
  pledgeId: 'pledgeId',
  recurringDonationId: 'recurringDonationId',
  amount: 'amount',
  currency: 'currency',
  status: 'status',
  provider: 'provider',
  providerRef: 'providerRef',
  isAnonymous: 'isAnonymous',
  donorName: 'donorName',
  donorEmail: 'donorEmail',
  donorPhone: 'donorPhone',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type DonationScalarFieldEnum = (typeof DonationScalarFieldEnum)[keyof typeof DonationScalarFieldEnum]


export const FundScalarFieldEnum = {
  id: 'id',
  churchId: 'churchId',
  name: 'name',
  description: 'description',
  isDefault: 'isDefault',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type FundScalarFieldEnum = (typeof FundScalarFieldEnum)[keyof typeof FundScalarFieldEnum]


export const CampaignScalarFieldEnum = {
  id: 'id',
  churchId: 'churchId',
  name: 'name',
  description: 'description',
  targetAmount: 'targetAmount',
  currency: 'currency',
  startAt: 'startAt',
  endAt: 'endAt',
  status: 'status',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CampaignScalarFieldEnum = (typeof CampaignScalarFieldEnum)[keyof typeof CampaignScalarFieldEnum]


export const PaymentIntentScalarFieldEnum = {
  id: 'id',
  churchId: 'churchId',
  memberId: 'memberId',
  amount: 'amount',
  currency: 'currency',
  provider: 'provider',
  providerRef: 'providerRef',
  status: 'status',
  checkoutUrl: 'checkoutUrl',
  metadata: 'metadata',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PaymentIntentScalarFieldEnum = (typeof PaymentIntentScalarFieldEnum)[keyof typeof PaymentIntentScalarFieldEnum]


export const DonationReceiptScalarFieldEnum = {
  id: 'id',
  donationId: 'donationId',
  churchId: 'churchId',
  receiptNumber: 'receiptNumber',
  voidReason: 'voidReason',
  status: 'status',
  issuedAt: 'issuedAt',
  metadata: 'metadata',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type DonationReceiptScalarFieldEnum = (typeof DonationReceiptScalarFieldEnum)[keyof typeof DonationReceiptScalarFieldEnum]


export const TextToGiveNumberScalarFieldEnum = {
  id: 'id',
  churchId: 'churchId',
  phoneNumber: 'phoneNumber',
  provider: 'provider',
  defaultCurrency: 'defaultCurrency',
  fundId: 'fundId',
  campaignId: 'campaignId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type TextToGiveNumberScalarFieldEnum = (typeof TextToGiveNumberScalarFieldEnum)[keyof typeof TextToGiveNumberScalarFieldEnum]


export const TextToGiveMessageScalarFieldEnum = {
  id: 'id',
  churchId: 'churchId',
  numberId: 'numberId',
  messageSid: 'messageSid',
  fromNumber: 'fromNumber',
  toNumber: 'toNumber',
  body: 'body',
  amount: 'amount',
  currency: 'currency',
  provider: 'provider',
  status: 'status',
  checkoutUrl: 'checkoutUrl',
  error: 'error',
  createdAt: 'createdAt'
} as const

export type TextToGiveMessageScalarFieldEnum = (typeof TextToGiveMessageScalarFieldEnum)[keyof typeof TextToGiveMessageScalarFieldEnum]


export const PayoutScalarFieldEnum = {
  id: 'id',
  provider: 'provider',
  providerRef: 'providerRef',
  tenantId: 'tenantId',
  churchId: 'churchId',
  currency: 'currency',
  amount: 'amount',
  status: 'status',
  arrivalDate: 'arrivalDate',
  metadata: 'metadata',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PayoutScalarFieldEnum = (typeof PayoutScalarFieldEnum)[keyof typeof PayoutScalarFieldEnum]


export const PayoutTransactionScalarFieldEnum = {
  id: 'id',
  payoutId: 'payoutId',
  tenantId: 'tenantId',
  churchId: 'churchId',
  donationId: 'donationId',
  providerRef: 'providerRef',
  sourceRef: 'sourceRef',
  type: 'type',
  amount: 'amount',
  fee: 'fee',
  net: 'net',
  currency: 'currency',
  description: 'description',
  metadata: 'metadata',
  createdAt: 'createdAt'
} as const

export type PayoutTransactionScalarFieldEnum = (typeof PayoutTransactionScalarFieldEnum)[keyof typeof PayoutTransactionScalarFieldEnum]


export const RefundScalarFieldEnum = {
  id: 'id',
  churchId: 'churchId',
  donationId: 'donationId',
  provider: 'provider',
  providerRef: 'providerRef',
  amount: 'amount',
  currency: 'currency',
  status: 'status',
  reason: 'reason',
  metadata: 'metadata',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type RefundScalarFieldEnum = (typeof RefundScalarFieldEnum)[keyof typeof RefundScalarFieldEnum]


export const DisputeScalarFieldEnum = {
  id: 'id',
  churchId: 'churchId',
  donationId: 'donationId',
  provider: 'provider',
  providerRef: 'providerRef',
  amount: 'amount',
  currency: 'currency',
  status: 'status',
  reason: 'reason',
  evidenceDueBy: 'evidenceDueBy',
  metadata: 'metadata',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type DisputeScalarFieldEnum = (typeof DisputeScalarFieldEnum)[keyof typeof DisputeScalarFieldEnum]


export const DisputeEvidenceScalarFieldEnum = {
  id: 'id',
  disputeId: 'disputeId',
  type: 'type',
  status: 'status',
  description: 'description',
  text: 'text',
  filePath: 'filePath',
  fileName: 'fileName',
  fileMime: 'fileMime',
  fileSize: 'fileSize',
  providerRef: 'providerRef',
  error: 'error',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type DisputeEvidenceScalarFieldEnum = (typeof DisputeEvidenceScalarFieldEnum)[keyof typeof DisputeEvidenceScalarFieldEnum]


export const CommunicationScheduleScalarFieldEnum = {
  id: 'id',
  churchId: 'churchId',
  templateId: 'templateId',
  dripEnrollmentId: 'dripEnrollmentId',
  dripStepId: 'dripStepId',
  channel: 'channel',
  provider: 'provider',
  to: 'to',
  subject: 'subject',
  body: 'body',
  sendAt: 'sendAt',
  status: 'status',
  error: 'error',
  metadata: 'metadata',
  createdAt: 'createdAt',
  sentAt: 'sentAt'
} as const

export type CommunicationScheduleScalarFieldEnum = (typeof CommunicationScheduleScalarFieldEnum)[keyof typeof CommunicationScheduleScalarFieldEnum]


export const CommunicationDripCampaignScalarFieldEnum = {
  id: 'id',
  churchId: 'churchId',
  name: 'name',
  description: 'description',
  status: 'status',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CommunicationDripCampaignScalarFieldEnum = (typeof CommunicationDripCampaignScalarFieldEnum)[keyof typeof CommunicationDripCampaignScalarFieldEnum]


export const CommunicationDripStepScalarFieldEnum = {
  id: 'id',
  campaignId: 'campaignId',
  stepOrder: 'stepOrder',
  delayHours: 'delayHours',
  channel: 'channel',
  templateId: 'templateId',
  subject: 'subject',
  body: 'body',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CommunicationDripStepScalarFieldEnum = (typeof CommunicationDripStepScalarFieldEnum)[keyof typeof CommunicationDripStepScalarFieldEnum]


export const CommunicationDripEnrollmentScalarFieldEnum = {
  id: 'id',
  campaignId: 'campaignId',
  churchId: 'churchId',
  recipient: 'recipient',
  memberId: 'memberId',
  donorEmail: 'donorEmail',
  donorPhone: 'donorPhone',
  status: 'status',
  enrolledAt: 'enrolledAt',
  completedAt: 'completedAt'
} as const

export type CommunicationDripEnrollmentScalarFieldEnum = (typeof CommunicationDripEnrollmentScalarFieldEnum)[keyof typeof CommunicationDripEnrollmentScalarFieldEnum]


export const CommunicationTemplateScalarFieldEnum = {
  id: 'id',
  churchId: 'churchId',
  name: 'name',
  channel: 'channel',
  subject: 'subject',
  body: 'body',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CommunicationTemplateScalarFieldEnum = (typeof CommunicationTemplateScalarFieldEnum)[keyof typeof CommunicationTemplateScalarFieldEnum]


export const CommunicationMessageScalarFieldEnum = {
  id: 'id',
  churchId: 'churchId',
  templateId: 'templateId',
  channel: 'channel',
  provider: 'provider',
  to: 'to',
  subject: 'subject',
  body: 'body',
  status: 'status',
  error: 'error',
  metadata: 'metadata',
  createdAt: 'createdAt',
  sentAt: 'sentAt'
} as const

export type CommunicationMessageScalarFieldEnum = (typeof CommunicationMessageScalarFieldEnum)[keyof typeof CommunicationMessageScalarFieldEnum]


export const CommunicationSuppressionScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  channel: 'channel',
  address: 'address',
  reason: 'reason',
  createdByClerkUserId: 'createdByClerkUserId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CommunicationSuppressionScalarFieldEnum = (typeof CommunicationSuppressionScalarFieldEnum)[keyof typeof CommunicationSuppressionScalarFieldEnum]


export const AiInteractionScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  churchId: 'churchId',
  clerkUserId: 'clerkUserId',
  provider: 'provider',
  model: 'model',
  question: 'question',
  answer: 'answer',
  sources: 'sources',
  createdAt: 'createdAt'
} as const

export type AiInteractionScalarFieldEnum = (typeof AiInteractionScalarFieldEnum)[keyof typeof AiInteractionScalarFieldEnum]


export const FundraiserPageScalarFieldEnum = {
  id: 'id',
  churchId: 'churchId',
  memberId: 'memberId',
  campaignId: 'campaignId',
  slug: 'slug',
  name: 'name',
  goalAmount: 'goalAmount',
  currency: 'currency',
  message: 'message',
  status: 'status',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type FundraiserPageScalarFieldEnum = (typeof FundraiserPageScalarFieldEnum)[keyof typeof FundraiserPageScalarFieldEnum]


export const PledgeScalarFieldEnum = {
  id: 'id',
  churchId: 'churchId',
  memberId: 'memberId',
  amount: 'amount',
  currency: 'currency',
  status: 'status',
  dueDate: 'dueDate',
  notes: 'notes',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PledgeScalarFieldEnum = (typeof PledgeScalarFieldEnum)[keyof typeof PledgeScalarFieldEnum]


export const RecurringDonationScalarFieldEnum = {
  id: 'id',
  churchId: 'churchId',
  memberId: 'memberId',
  amount: 'amount',
  currency: 'currency',
  interval: 'interval',
  status: 'status',
  provider: 'provider',
  providerRef: 'providerRef',
  startAt: 'startAt',
  nextChargeAt: 'nextChargeAt',
  lastChargeAt: 'lastChargeAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type RecurringDonationScalarFieldEnum = (typeof RecurringDonationScalarFieldEnum)[keyof typeof RecurringDonationScalarFieldEnum]


export const ExpenseCategoryScalarFieldEnum = {
  id: 'id',
  churchId: 'churchId',
  name: 'name',
  description: 'description',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ExpenseCategoryScalarFieldEnum = (typeof ExpenseCategoryScalarFieldEnum)[keyof typeof ExpenseCategoryScalarFieldEnum]


export const ExpenseScalarFieldEnum = {
  id: 'id',
  churchId: 'churchId',
  categoryId: 'categoryId',
  amount: 'amount',
  currency: 'currency',
  status: 'status',
  description: 'description',
  vendor: 'vendor',
  occurredAt: 'occurredAt',
  submittedById: 'submittedById',
  approvedById: 'approvedById',
  approvedAt: 'approvedAt',
  paidAt: 'paidAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ExpenseScalarFieldEnum = (typeof ExpenseScalarFieldEnum)[keyof typeof ExpenseScalarFieldEnum]


export const BudgetScalarFieldEnum = {
  id: 'id',
  churchId: 'churchId',
  name: 'name',
  startAt: 'startAt',
  endAt: 'endAt',
  status: 'status',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type BudgetScalarFieldEnum = (typeof BudgetScalarFieldEnum)[keyof typeof BudgetScalarFieldEnum]


export const BudgetItemScalarFieldEnum = {
  id: 'id',
  budgetId: 'budgetId',
  categoryId: 'categoryId',
  name: 'name',
  allocatedAmount: 'allocatedAmount',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type BudgetItemScalarFieldEnum = (typeof BudgetItemScalarFieldEnum)[keyof typeof BudgetItemScalarFieldEnum]


export const AuditLogScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  churchId: 'churchId',
  actorType: 'actorType',
  actorId: 'actorId',
  action: 'action',
  targetType: 'targetType',
  targetId: 'targetId',
  metadata: 'metadata',
  createdAt: 'createdAt'
} as const

export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


export const UserScalarFieldEnum = {
  id: 'id',
  clerkUserId: 'clerkUserId',
  email: 'email',
  name: 'name',
  role: 'role',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


export const StaffMembershipScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  churchId: 'churchId',
  role: 'role',
  createdAt: 'createdAt'
} as const

export type StaffMembershipScalarFieldEnum = (typeof StaffMembershipScalarFieldEnum)[keyof typeof StaffMembershipScalarFieldEnum]


export const FacilityScalarFieldEnum = {
  id: 'id',
  churchId: 'churchId',
  campusId: 'campusId',
  name: 'name',
  type: 'type',
  description: 'description',
  capacity: 'capacity',
  location: 'location',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type FacilityScalarFieldEnum = (typeof FacilityScalarFieldEnum)[keyof typeof FacilityScalarFieldEnum]


export const FacilityBookingScalarFieldEnum = {
  id: 'id',
  churchId: 'churchId',
  facilityId: 'facilityId',
  eventId: 'eventId',
  bookedByUserId: 'bookedByUserId',
  title: 'title',
  description: 'description',
  startAt: 'startAt',
  endAt: 'endAt',
  status: 'status',
  notes: 'notes',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type FacilityBookingScalarFieldEnum = (typeof FacilityBookingScalarFieldEnum)[keyof typeof FacilityBookingScalarFieldEnum]


export const CareRequestScalarFieldEnum = {
  id: 'id',
  churchId: 'churchId',
  campusId: 'campusId',
  memberId: 'memberId',
  requestedByMemberId: 'requestedByMemberId',
  assignedToUserId: 'assignedToUserId',
  title: 'title',
  details: 'details',
  status: 'status',
  priority: 'priority',
  channel: 'channel',
  dueAt: 'dueAt',
  openedAt: 'openedAt',
  assignedAt: 'assignedAt',
  closedAt: 'closedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CareRequestScalarFieldEnum = (typeof CareRequestScalarFieldEnum)[keyof typeof CareRequestScalarFieldEnum]


export const CareNoteScalarFieldEnum = {
  id: 'id',
  careRequestId: 'careRequestId',
  authorUserId: 'authorUserId',
  authorMemberId: 'authorMemberId',
  note: 'note',
  isPrivate: 'isPrivate',
  createdAt: 'createdAt'
} as const

export type CareNoteScalarFieldEnum = (typeof CareNoteScalarFieldEnum)[keyof typeof CareNoteScalarFieldEnum]


export const SermonScalarFieldEnum = {
  id: 'id',
  churchId: 'churchId',
  campusId: 'campusId',
  eventId: 'eventId',
  mediaAssetId: 'mediaAssetId',
  title: 'title',
  speaker: 'speaker',
  seriesName: 'seriesName',
  summary: 'summary',
  scriptureRefs: 'scriptureRefs',
  durationSeconds: 'durationSeconds',
  status: 'status',
  publishedAt: 'publishedAt',
  viewCount: 'viewCount',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type SermonScalarFieldEnum = (typeof SermonScalarFieldEnum)[keyof typeof SermonScalarFieldEnum]


export const ContentResourceScalarFieldEnum = {
  id: 'id',
  churchId: 'churchId',
  campusId: 'campusId',
  mediaAssetId: 'mediaAssetId',
  title: 'title',
  description: 'description',
  type: 'type',
  visibility: 'visibility',
  linkUrl: 'linkUrl',
  tags: 'tags',
  isFeatured: 'isFeatured',
  publishedAt: 'publishedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ContentResourceScalarFieldEnum = (typeof ContentResourceScalarFieldEnum)[keyof typeof ContentResourceScalarFieldEnum]


export const TenantDomainScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  domain: 'domain',
  status: 'status',
  verificationToken: 'verificationToken',
  dnsTarget: 'dnsTarget',
  verifiedAt: 'verifiedAt',
  sslStatus: 'sslStatus',
  sslExpiresAt: 'sslExpiresAt',
  lastCheckedAt: 'lastCheckedAt',
  notes: 'notes',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type TenantDomainScalarFieldEnum = (typeof TenantDomainScalarFieldEnum)[keyof typeof TenantDomainScalarFieldEnum]


export const TenantHealthCheckScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  type: 'type',
  status: 'status',
  latencyMs: 'latencyMs',
  details: 'details',
  checkedAt: 'checkedAt'
} as const

export type TenantHealthCheckScalarFieldEnum = (typeof TenantHealthCheckScalarFieldEnum)[keyof typeof TenantHealthCheckScalarFieldEnum]


export const TenantSecurityPolicyScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  requireMfaForStaff: 'requireMfaForStaff',
  enforceSso: 'enforceSso',
  sessionTimeoutMinutes: 'sessionTimeoutMinutes',
  dataRetentionDays: 'dataRetentionDays',
  ipAllowlist: 'ipAllowlist',
  breachContactEmail: 'breachContactEmail',
  updatedBy: 'updatedBy',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type TenantSecurityPolicyScalarFieldEnum = (typeof TenantSecurityPolicyScalarFieldEnum)[keyof typeof TenantSecurityPolicyScalarFieldEnum]


export const SupportTicketScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  churchId: 'churchId',
  requesterEmail: 'requesterEmail',
  requesterName: 'requesterName',
  subject: 'subject',
  description: 'description',
  status: 'status',
  priority: 'priority',
  source: 'source',
  firstResponseDueAt: 'firstResponseDueAt',
  firstRespondedAt: 'firstRespondedAt',
  firstResponseBreachedAt: 'firstResponseBreachedAt',
  resolutionDueAt: 'resolutionDueAt',
  resolutionBreachedAt: 'resolutionBreachedAt',
  lastSlaCheckAt: 'lastSlaCheckAt',
  reopenedCount: 'reopenedCount',
  assignedToPlatformUserId: 'assignedToPlatformUserId',
  resolvedAt: 'resolvedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type SupportTicketScalarFieldEnum = (typeof SupportTicketScalarFieldEnum)[keyof typeof SupportTicketScalarFieldEnum]


export const SupportTicketMessageScalarFieldEnum = {
  id: 'id',
  ticketId: 'ticketId',
  authorType: 'authorType',
  authorPlatformUserId: 'authorPlatformUserId',
  authorTenantUserId: 'authorTenantUserId',
  body: 'body',
  isInternal: 'isInternal',
  createdAt: 'createdAt'
} as const

export type SupportTicketMessageScalarFieldEnum = (typeof SupportTicketMessageScalarFieldEnum)[keyof typeof SupportTicketMessageScalarFieldEnum]


export const WebhookEventScalarFieldEnum = {
  id: 'id',
  provider: 'provider',
  externalEventId: 'externalEventId',
  eventType: 'eventType',
  payloadHash: 'payloadHash',
  status: 'status',
  tenantId: 'tenantId',
  churchId: 'churchId',
  receivedAt: 'receivedAt',
  processedAt: 'processedAt',
  result: 'result',
  error: 'error',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type WebhookEventScalarFieldEnum = (typeof WebhookEventScalarFieldEnum)[keyof typeof WebhookEventScalarFieldEnum]


export const LiveStreamChannelScalarFieldEnum = {
  id: 'id',
  churchId: 'churchId',
  campusId: 'campusId',
  name: 'name',
  provider: 'provider',
  externalChannelId: 'externalChannelId',
  ingestUrl: 'ingestUrl',
  playbackUrl: 'playbackUrl',
  streamKey: 'streamKey',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type LiveStreamChannelScalarFieldEnum = (typeof LiveStreamChannelScalarFieldEnum)[keyof typeof LiveStreamChannelScalarFieldEnum]


export const LiveStreamSessionScalarFieldEnum = {
  id: 'id',
  churchId: 'churchId',
  channelId: 'channelId',
  eventId: 'eventId',
  title: 'title',
  description: 'description',
  status: 'status',
  moderationLevel: 'moderationLevel',
  scheduledStartAt: 'scheduledStartAt',
  startedAt: 'startedAt',
  endedAt: 'endedAt',
  isRecording: 'isRecording',
  recordingUrl: 'recordingUrl',
  peakViewers: 'peakViewers',
  totalViews: 'totalViews',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type LiveStreamSessionScalarFieldEnum = (typeof LiveStreamSessionScalarFieldEnum)[keyof typeof LiveStreamSessionScalarFieldEnum]


export const SortOrder = {
  asc: 'asc',
  desc: 'desc'
} as const

export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


export const NullableJsonNullValueInput = {
  DbNull: DbNull,
  JsonNull: JsonNull
} as const

export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


export const JsonNullValueInput = {
  JsonNull: JsonNull
} as const

export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


export const QueryMode = {
  default: 'default',
  insensitive: 'insensitive'
} as const

export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


export const NullsOrder = {
  first: 'first',
  last: 'last'
} as const

export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


export const JsonNullValueFilter = {
  DbNull: DbNull,
  JsonNull: JsonNull,
  AnyNull: AnyNull
} as const

export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]



/**
 * Field references
 */


/**
 * Reference to a field of type 'String'
 */
export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


/**
 * Reference to a field of type 'String[]'
 */
export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


/**
 * Reference to a field of type 'TenantStatus'
 */
export type EnumTenantStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TenantStatus'>
    


/**
 * Reference to a field of type 'TenantStatus[]'
 */
export type ListEnumTenantStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TenantStatus[]'>
    


/**
 * Reference to a field of type 'DateTime'
 */
export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


/**
 * Reference to a field of type 'DateTime[]'
 */
export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


/**
 * Reference to a field of type 'MemberStatus'
 */
export type EnumMemberStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MemberStatus'>
    


/**
 * Reference to a field of type 'MemberStatus[]'
 */
export type ListEnumMemberStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MemberStatus[]'>
    


/**
 * Reference to a field of type 'MemberGender'
 */
export type EnumMemberGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MemberGender'>
    


/**
 * Reference to a field of type 'MemberGender[]'
 */
export type ListEnumMemberGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MemberGender[]'>
    


/**
 * Reference to a field of type 'MemberMaritalStatus'
 */
export type EnumMemberMaritalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MemberMaritalStatus'>
    


/**
 * Reference to a field of type 'MemberMaritalStatus[]'
 */
export type ListEnumMemberMaritalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MemberMaritalStatus[]'>
    


/**
 * Reference to a field of type 'MemberDirectoryVisibility'
 */
export type EnumMemberDirectoryVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MemberDirectoryVisibility'>
    


/**
 * Reference to a field of type 'MemberDirectoryVisibility[]'
 */
export type ListEnumMemberDirectoryVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MemberDirectoryVisibility[]'>
    


/**
 * Reference to a field of type 'Boolean'
 */
export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


/**
 * Reference to a field of type 'AccessRequestStatus'
 */
export type EnumAccessRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccessRequestStatus'>
    


/**
 * Reference to a field of type 'AccessRequestStatus[]'
 */
export type ListEnumAccessRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccessRequestStatus[]'>
    


/**
 * Reference to a field of type 'UserRole'
 */
export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


/**
 * Reference to a field of type 'UserRole[]'
 */
export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


/**
 * Reference to a field of type 'StaffInviteStatus'
 */
export type EnumStaffInviteStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StaffInviteStatus'>
    


/**
 * Reference to a field of type 'StaffInviteStatus[]'
 */
export type ListEnumStaffInviteStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StaffInviteStatus[]'>
    


/**
 * Reference to a field of type 'PlatformUserStatus'
 */
export type EnumPlatformUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlatformUserStatus'>
    


/**
 * Reference to a field of type 'PlatformUserStatus[]'
 */
export type ListEnumPlatformUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlatformUserStatus[]'>
    


/**
 * Reference to a field of type 'PlatformRole'
 */
export type EnumPlatformRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlatformRole'>
    


/**
 * Reference to a field of type 'PlatformRole[]'
 */
export type ListEnumPlatformRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlatformRole[]'>
    


/**
 * Reference to a field of type 'BillingInterval'
 */
export type EnumBillingIntervalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BillingInterval'>
    


/**
 * Reference to a field of type 'BillingInterval[]'
 */
export type ListEnumBillingIntervalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BillingInterval[]'>
    


/**
 * Reference to a field of type 'Int'
 */
export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


/**
 * Reference to a field of type 'Int[]'
 */
export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


/**
 * Reference to a field of type 'Json'
 */
export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


/**
 * Reference to a field of type 'QueryMode'
 */
export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


/**
 * Reference to a field of type 'TenantSubscriptionStatus'
 */
export type EnumTenantSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TenantSubscriptionStatus'>
    


/**
 * Reference to a field of type 'TenantSubscriptionStatus[]'
 */
export type ListEnumTenantSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TenantSubscriptionStatus[]'>
    


/**
 * Reference to a field of type 'SubscriptionProvider'
 */
export type EnumSubscriptionProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionProvider'>
    


/**
 * Reference to a field of type 'SubscriptionProvider[]'
 */
export type ListEnumSubscriptionProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionProvider[]'>
    


/**
 * Reference to a field of type 'ImportEntityType'
 */
export type EnumImportEntityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ImportEntityType'>
    


/**
 * Reference to a field of type 'ImportEntityType[]'
 */
export type ListEnumImportEntityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ImportEntityType[]'>
    


/**
 * Reference to a field of type 'ImportBatchStatus'
 */
export type EnumImportBatchStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ImportBatchStatus'>
    


/**
 * Reference to a field of type 'ImportBatchStatus[]'
 */
export type ListEnumImportBatchStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ImportBatchStatus[]'>
    


/**
 * Reference to a field of type 'ImportItemAction'
 */
export type EnumImportItemActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ImportItemAction'>
    


/**
 * Reference to a field of type 'ImportItemAction[]'
 */
export type ListEnumImportItemActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ImportItemAction[]'>
    


/**
 * Reference to a field of type 'RegistrationStatus'
 */
export type EnumRegistrationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RegistrationStatus'>
    


/**
 * Reference to a field of type 'RegistrationStatus[]'
 */
export type ListEnumRegistrationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RegistrationStatus[]'>
    


/**
 * Reference to a field of type 'MemberMilestoneType'
 */
export type EnumMemberMilestoneTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MemberMilestoneType'>
    


/**
 * Reference to a field of type 'MemberMilestoneType[]'
 */
export type ListEnumMemberMilestoneTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MemberMilestoneType[]'>
    


/**
 * Reference to a field of type 'GroupType'
 */
export type EnumGroupTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GroupType'>
    


/**
 * Reference to a field of type 'GroupType[]'
 */
export type ListEnumGroupTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GroupType[]'>
    


/**
 * Reference to a field of type 'GroupStatus'
 */
export type EnumGroupStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GroupStatus'>
    


/**
 * Reference to a field of type 'GroupStatus[]'
 */
export type ListEnumGroupStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GroupStatus[]'>
    


/**
 * Reference to a field of type 'OnboardingWorkflowStatus'
 */
export type EnumOnboardingWorkflowStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OnboardingWorkflowStatus'>
    


/**
 * Reference to a field of type 'OnboardingWorkflowStatus[]'
 */
export type ListEnumOnboardingWorkflowStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OnboardingWorkflowStatus[]'>
    


/**
 * Reference to a field of type 'OnboardingStepType'
 */
export type EnumOnboardingStepTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OnboardingStepType'>
    


/**
 * Reference to a field of type 'OnboardingStepType[]'
 */
export type ListEnumOnboardingStepTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OnboardingStepType[]'>
    


/**
 * Reference to a field of type 'OnboardingTaskStatus'
 */
export type EnumOnboardingTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OnboardingTaskStatus'>
    


/**
 * Reference to a field of type 'OnboardingTaskStatus[]'
 */
export type ListEnumOnboardingTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OnboardingTaskStatus[]'>
    


/**
 * Reference to a field of type 'GroupMemberRole'
 */
export type EnumGroupMemberRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GroupMemberRole'>
    


/**
 * Reference to a field of type 'GroupMemberRole[]'
 */
export type ListEnumGroupMemberRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GroupMemberRole[]'>
    


/**
 * Reference to a field of type 'VolunteerRoleStatus'
 */
export type EnumVolunteerRoleStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VolunteerRoleStatus'>
    


/**
 * Reference to a field of type 'VolunteerRoleStatus[]'
 */
export type ListEnumVolunteerRoleStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VolunteerRoleStatus[]'>
    


/**
 * Reference to a field of type 'VolunteerShiftAssignmentStatus'
 */
export type EnumVolunteerShiftAssignmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VolunteerShiftAssignmentStatus'>
    


/**
 * Reference to a field of type 'VolunteerShiftAssignmentStatus[]'
 */
export type ListEnumVolunteerShiftAssignmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VolunteerShiftAssignmentStatus[]'>
    


/**
 * Reference to a field of type 'Weekday'
 */
export type EnumWeekdayFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Weekday'>
    


/**
 * Reference to a field of type 'Weekday[]'
 */
export type ListEnumWeekdayFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Weekday[]'>
    


/**
 * Reference to a field of type 'SurveyStatus'
 */
export type EnumSurveyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SurveyStatus'>
    


/**
 * Reference to a field of type 'SurveyStatus[]'
 */
export type ListEnumSurveyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SurveyStatus[]'>
    


/**
 * Reference to a field of type 'SurveyQuestionType'
 */
export type EnumSurveyQuestionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SurveyQuestionType'>
    


/**
 * Reference to a field of type 'SurveyQuestionType[]'
 */
export type ListEnumSurveyQuestionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SurveyQuestionType[]'>
    


/**
 * Reference to a field of type 'VolunteerAssignmentStatus'
 */
export type EnumVolunteerAssignmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VolunteerAssignmentStatus'>
    


/**
 * Reference to a field of type 'VolunteerAssignmentStatus[]'
 */
export type ListEnumVolunteerAssignmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VolunteerAssignmentStatus[]'>
    


/**
 * Reference to a field of type 'EventType'
 */
export type EnumEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventType'>
    


/**
 * Reference to a field of type 'EventType[]'
 */
export type ListEnumEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventType[]'>
    


/**
 * Reference to a field of type 'EventFormat'
 */
export type EnumEventFormatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventFormat'>
    


/**
 * Reference to a field of type 'EventFormat[]'
 */
export type ListEnumEventFormatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventFormat[]'>
    


/**
 * Reference to a field of type 'EventVisibility'
 */
export type EnumEventVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventVisibility'>
    


/**
 * Reference to a field of type 'EventVisibility[]'
 */
export type ListEnumEventVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventVisibility[]'>
    


/**
 * Reference to a field of type 'EventRecurrenceFrequency'
 */
export type EnumEventRecurrenceFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventRecurrenceFrequency'>
    


/**
 * Reference to a field of type 'EventRecurrenceFrequency[]'
 */
export type ListEnumEventRecurrenceFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventRecurrenceFrequency[]'>
    


/**
 * Reference to a field of type 'EventRsvpStatus'
 */
export type EnumEventRsvpStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventRsvpStatus'>
    


/**
 * Reference to a field of type 'EventRsvpStatus[]'
 */
export type ListEnumEventRsvpStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventRsvpStatus[]'>
    


/**
 * Reference to a field of type 'EventBadgeStatus'
 */
export type EnumEventBadgeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventBadgeStatus'>
    


/**
 * Reference to a field of type 'EventBadgeStatus[]'
 */
export type ListEnumEventBadgeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventBadgeStatus[]'>
    


/**
 * Reference to a field of type 'EventRegistrationStatus'
 */
export type EnumEventRegistrationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventRegistrationStatus'>
    


/**
 * Reference to a field of type 'EventRegistrationStatus[]'
 */
export type ListEnumEventRegistrationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventRegistrationStatus[]'>
    


/**
 * Reference to a field of type 'EventAssignmentRole'
 */
export type EnumEventAssignmentRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventAssignmentRole'>
    


/**
 * Reference to a field of type 'EventAssignmentRole[]'
 */
export type ListEnumEventAssignmentRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventAssignmentRole[]'>
    


/**
 * Reference to a field of type 'EventMediaType'
 */
export type EnumEventMediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventMediaType'>
    


/**
 * Reference to a field of type 'EventMediaType[]'
 */
export type ListEnumEventMediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventMediaType[]'>
    


/**
 * Reference to a field of type 'Decimal'
 */
export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


/**
 * Reference to a field of type 'Decimal[]'
 */
export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


/**
 * Reference to a field of type 'PaymentProvider'
 */
export type EnumPaymentProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentProvider'>
    


/**
 * Reference to a field of type 'PaymentProvider[]'
 */
export type ListEnumPaymentProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentProvider[]'>
    


/**
 * Reference to a field of type 'TicketOrderStatus'
 */
export type EnumTicketOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketOrderStatus'>
    


/**
 * Reference to a field of type 'TicketOrderStatus[]'
 */
export type ListEnumTicketOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketOrderStatus[]'>
    


/**
 * Reference to a field of type 'ConversationType'
 */
export type EnumConversationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConversationType'>
    


/**
 * Reference to a field of type 'ConversationType[]'
 */
export type ListEnumConversationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConversationType[]'>
    


/**
 * Reference to a field of type 'ConversationMemberRole'
 */
export type EnumConversationMemberRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConversationMemberRole'>
    


/**
 * Reference to a field of type 'ConversationMemberRole[]'
 */
export type ListEnumConversationMemberRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConversationMemberRole[]'>
    


/**
 * Reference to a field of type 'MessageSenderType'
 */
export type EnumMessageSenderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageSenderType'>
    


/**
 * Reference to a field of type 'MessageSenderType[]'
 */
export type ListEnumMessageSenderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageSenderType[]'>
    


/**
 * Reference to a field of type 'StorageProvider'
 */
export type EnumStorageProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StorageProvider'>
    


/**
 * Reference to a field of type 'StorageProvider[]'
 */
export type ListEnumStorageProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StorageProvider[]'>
    


/**
 * Reference to a field of type 'NotificationChannel'
 */
export type EnumNotificationChannelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationChannel'>
    


/**
 * Reference to a field of type 'NotificationChannel[]'
 */
export type ListEnumNotificationChannelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationChannel[]'>
    


/**
 * Reference to a field of type 'NotificationCategory'
 */
export type EnumNotificationCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationCategory'>
    


/**
 * Reference to a field of type 'NotificationCategory[]'
 */
export type ListEnumNotificationCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationCategory[]'>
    


/**
 * Reference to a field of type 'DevicePlatform'
 */
export type EnumDevicePlatformFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DevicePlatform'>
    


/**
 * Reference to a field of type 'DevicePlatform[]'
 */
export type ListEnumDevicePlatformFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DevicePlatform[]'>
    


/**
 * Reference to a field of type 'MemberRelationshipType'
 */
export type EnumMemberRelationshipTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MemberRelationshipType'>
    


/**
 * Reference to a field of type 'MemberRelationshipType[]'
 */
export type ListEnumMemberRelationshipTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MemberRelationshipType[]'>
    


/**
 * Reference to a field of type 'DonationStatus'
 */
export type EnumDonationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DonationStatus'>
    


/**
 * Reference to a field of type 'DonationStatus[]'
 */
export type ListEnumDonationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DonationStatus[]'>
    


/**
 * Reference to a field of type 'CampaignStatus'
 */
export type EnumCampaignStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CampaignStatus'>
    


/**
 * Reference to a field of type 'CampaignStatus[]'
 */
export type ListEnumCampaignStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CampaignStatus[]'>
    


/**
 * Reference to a field of type 'PaymentIntentStatus'
 */
export type EnumPaymentIntentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentIntentStatus'>
    


/**
 * Reference to a field of type 'PaymentIntentStatus[]'
 */
export type ListEnumPaymentIntentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentIntentStatus[]'>
    


/**
 * Reference to a field of type 'ReceiptStatus'
 */
export type EnumReceiptStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReceiptStatus'>
    


/**
 * Reference to a field of type 'ReceiptStatus[]'
 */
export type ListEnumReceiptStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReceiptStatus[]'>
    


/**
 * Reference to a field of type 'DisputeEvidenceType'
 */
export type EnumDisputeEvidenceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DisputeEvidenceType'>
    


/**
 * Reference to a field of type 'DisputeEvidenceType[]'
 */
export type ListEnumDisputeEvidenceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DisputeEvidenceType[]'>
    


/**
 * Reference to a field of type 'DisputeEvidenceStatus'
 */
export type EnumDisputeEvidenceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DisputeEvidenceStatus'>
    


/**
 * Reference to a field of type 'DisputeEvidenceStatus[]'
 */
export type ListEnumDisputeEvidenceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DisputeEvidenceStatus[]'>
    


/**
 * Reference to a field of type 'CommunicationChannel'
 */
export type EnumCommunicationChannelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CommunicationChannel'>
    


/**
 * Reference to a field of type 'CommunicationChannel[]'
 */
export type ListEnumCommunicationChannelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CommunicationChannel[]'>
    


/**
 * Reference to a field of type 'CommunicationProvider'
 */
export type EnumCommunicationProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CommunicationProvider'>
    


/**
 * Reference to a field of type 'CommunicationProvider[]'
 */
export type ListEnumCommunicationProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CommunicationProvider[]'>
    


/**
 * Reference to a field of type 'CommunicationScheduleStatus'
 */
export type EnumCommunicationScheduleStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CommunicationScheduleStatus'>
    


/**
 * Reference to a field of type 'CommunicationScheduleStatus[]'
 */
export type ListEnumCommunicationScheduleStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CommunicationScheduleStatus[]'>
    


/**
 * Reference to a field of type 'DripCampaignStatus'
 */
export type EnumDripCampaignStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DripCampaignStatus'>
    


/**
 * Reference to a field of type 'DripCampaignStatus[]'
 */
export type ListEnumDripCampaignStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DripCampaignStatus[]'>
    


/**
 * Reference to a field of type 'DripEnrollmentStatus'
 */
export type EnumDripEnrollmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DripEnrollmentStatus'>
    


/**
 * Reference to a field of type 'DripEnrollmentStatus[]'
 */
export type ListEnumDripEnrollmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DripEnrollmentStatus[]'>
    


/**
 * Reference to a field of type 'CommunicationStatus'
 */
export type EnumCommunicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CommunicationStatus'>
    


/**
 * Reference to a field of type 'CommunicationStatus[]'
 */
export type ListEnumCommunicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CommunicationStatus[]'>
    


/**
 * Reference to a field of type 'CommunicationSuppressionReason'
 */
export type EnumCommunicationSuppressionReasonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CommunicationSuppressionReason'>
    


/**
 * Reference to a field of type 'CommunicationSuppressionReason[]'
 */
export type ListEnumCommunicationSuppressionReasonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CommunicationSuppressionReason[]'>
    


/**
 * Reference to a field of type 'FundraiserStatus'
 */
export type EnumFundraiserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FundraiserStatus'>
    


/**
 * Reference to a field of type 'FundraiserStatus[]'
 */
export type ListEnumFundraiserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FundraiserStatus[]'>
    


/**
 * Reference to a field of type 'PledgeStatus'
 */
export type EnumPledgeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PledgeStatus'>
    


/**
 * Reference to a field of type 'PledgeStatus[]'
 */
export type ListEnumPledgeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PledgeStatus[]'>
    


/**
 * Reference to a field of type 'RecurringInterval'
 */
export type EnumRecurringIntervalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecurringInterval'>
    


/**
 * Reference to a field of type 'RecurringInterval[]'
 */
export type ListEnumRecurringIntervalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecurringInterval[]'>
    


/**
 * Reference to a field of type 'RecurringStatus'
 */
export type EnumRecurringStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecurringStatus'>
    


/**
 * Reference to a field of type 'RecurringStatus[]'
 */
export type ListEnumRecurringStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecurringStatus[]'>
    


/**
 * Reference to a field of type 'ExpenseStatus'
 */
export type EnumExpenseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExpenseStatus'>
    


/**
 * Reference to a field of type 'ExpenseStatus[]'
 */
export type ListEnumExpenseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExpenseStatus[]'>
    


/**
 * Reference to a field of type 'BudgetStatus'
 */
export type EnumBudgetStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BudgetStatus'>
    


/**
 * Reference to a field of type 'BudgetStatus[]'
 */
export type ListEnumBudgetStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BudgetStatus[]'>
    


/**
 * Reference to a field of type 'AuditActorType'
 */
export type EnumAuditActorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditActorType'>
    


/**
 * Reference to a field of type 'AuditActorType[]'
 */
export type ListEnumAuditActorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditActorType[]'>
    


/**
 * Reference to a field of type 'FacilityType'
 */
export type EnumFacilityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FacilityType'>
    


/**
 * Reference to a field of type 'FacilityType[]'
 */
export type ListEnumFacilityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FacilityType[]'>
    


/**
 * Reference to a field of type 'FacilityBookingStatus'
 */
export type EnumFacilityBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FacilityBookingStatus'>
    


/**
 * Reference to a field of type 'FacilityBookingStatus[]'
 */
export type ListEnumFacilityBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FacilityBookingStatus[]'>
    


/**
 * Reference to a field of type 'CareRequestStatus'
 */
export type EnumCareRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CareRequestStatus'>
    


/**
 * Reference to a field of type 'CareRequestStatus[]'
 */
export type ListEnumCareRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CareRequestStatus[]'>
    


/**
 * Reference to a field of type 'CareRequestPriority'
 */
export type EnumCareRequestPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CareRequestPriority'>
    


/**
 * Reference to a field of type 'CareRequestPriority[]'
 */
export type ListEnumCareRequestPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CareRequestPriority[]'>
    


/**
 * Reference to a field of type 'CareRequestChannel'
 */
export type EnumCareRequestChannelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CareRequestChannel'>
    


/**
 * Reference to a field of type 'CareRequestChannel[]'
 */
export type ListEnumCareRequestChannelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CareRequestChannel[]'>
    


/**
 * Reference to a field of type 'SermonStatus'
 */
export type EnumSermonStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SermonStatus'>
    


/**
 * Reference to a field of type 'SermonStatus[]'
 */
export type ListEnumSermonStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SermonStatus[]'>
    


/**
 * Reference to a field of type 'ContentResourceType'
 */
export type EnumContentResourceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContentResourceType'>
    


/**
 * Reference to a field of type 'ContentResourceType[]'
 */
export type ListEnumContentResourceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContentResourceType[]'>
    


/**
 * Reference to a field of type 'ContentResourceVisibility'
 */
export type EnumContentResourceVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContentResourceVisibility'>
    


/**
 * Reference to a field of type 'ContentResourceVisibility[]'
 */
export type ListEnumContentResourceVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContentResourceVisibility[]'>
    


/**
 * Reference to a field of type 'TenantDomainStatus'
 */
export type EnumTenantDomainStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TenantDomainStatus'>
    


/**
 * Reference to a field of type 'TenantDomainStatus[]'
 */
export type ListEnumTenantDomainStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TenantDomainStatus[]'>
    


/**
 * Reference to a field of type 'TenantSslStatus'
 */
export type EnumTenantSslStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TenantSslStatus'>
    


/**
 * Reference to a field of type 'TenantSslStatus[]'
 */
export type ListEnumTenantSslStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TenantSslStatus[]'>
    


/**
 * Reference to a field of type 'HealthCheckType'
 */
export type EnumHealthCheckTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HealthCheckType'>
    


/**
 * Reference to a field of type 'HealthCheckType[]'
 */
export type ListEnumHealthCheckTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HealthCheckType[]'>
    


/**
 * Reference to a field of type 'HealthCheckStatus'
 */
export type EnumHealthCheckStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HealthCheckStatus'>
    


/**
 * Reference to a field of type 'HealthCheckStatus[]'
 */
export type ListEnumHealthCheckStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HealthCheckStatus[]'>
    


/**
 * Reference to a field of type 'SupportTicketStatus'
 */
export type EnumSupportTicketStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SupportTicketStatus'>
    


/**
 * Reference to a field of type 'SupportTicketStatus[]'
 */
export type ListEnumSupportTicketStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SupportTicketStatus[]'>
    


/**
 * Reference to a field of type 'SupportTicketPriority'
 */
export type EnumSupportTicketPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SupportTicketPriority'>
    


/**
 * Reference to a field of type 'SupportTicketPriority[]'
 */
export type ListEnumSupportTicketPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SupportTicketPriority[]'>
    


/**
 * Reference to a field of type 'SupportTicketSource'
 */
export type EnumSupportTicketSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SupportTicketSource'>
    


/**
 * Reference to a field of type 'SupportTicketSource[]'
 */
export type ListEnumSupportTicketSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SupportTicketSource[]'>
    


/**
 * Reference to a field of type 'SupportMessageAuthorType'
 */
export type EnumSupportMessageAuthorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SupportMessageAuthorType'>
    


/**
 * Reference to a field of type 'SupportMessageAuthorType[]'
 */
export type ListEnumSupportMessageAuthorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SupportMessageAuthorType[]'>
    


/**
 * Reference to a field of type 'WebhookProvider'
 */
export type EnumWebhookProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WebhookProvider'>
    


/**
 * Reference to a field of type 'WebhookProvider[]'
 */
export type ListEnumWebhookProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WebhookProvider[]'>
    


/**
 * Reference to a field of type 'WebhookEventStatus'
 */
export type EnumWebhookEventStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WebhookEventStatus'>
    


/**
 * Reference to a field of type 'WebhookEventStatus[]'
 */
export type ListEnumWebhookEventStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WebhookEventStatus[]'>
    


/**
 * Reference to a field of type 'LiveStreamProvider'
 */
export type EnumLiveStreamProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LiveStreamProvider'>
    


/**
 * Reference to a field of type 'LiveStreamProvider[]'
 */
export type ListEnumLiveStreamProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LiveStreamProvider[]'>
    


/**
 * Reference to a field of type 'LiveStreamStatus'
 */
export type EnumLiveStreamStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LiveStreamStatus'>
    


/**
 * Reference to a field of type 'LiveStreamStatus[]'
 */
export type ListEnumLiveStreamStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LiveStreamStatus[]'>
    


/**
 * Reference to a field of type 'LiveModerationLevel'
 */
export type EnumLiveModerationLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LiveModerationLevel'>
    


/**
 * Reference to a field of type 'LiveModerationLevel[]'
 */
export type ListEnumLiveModerationLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LiveModerationLevel[]'>
    


/**
 * Reference to a field of type 'Float'
 */
export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


/**
 * Reference to a field of type 'Float[]'
 */
export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    

/**
 * Batch Payload for updateMany & deleteMany & createMany
 */
export type BatchPayload = {
  count: number
}

export const defineExtension = runtime.Extensions.defineExtension as unknown as runtime.Types.Extensions.ExtendsHook<"define", TypeMapCb, runtime.Types.Extensions.DefaultArgs>
export type DefaultPrismaClient = PrismaClient
export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
export type PrismaClientOptions = ({
  /**
   * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-pg`.
   */
  adapter: runtime.SqlDriverAdapterFactory
  accelerateUrl?: never
} | {
  /**
   * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
   */
  accelerateUrl: string
  adapter?: never
}) & {
  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat
  /**
   * @example
   * ```
   * // Shorthand for `emit: 'stdout'`
   * log: ['query', 'info', 'warn', 'error']
   * 
   * // Emit as events only
   * log: [
   *   { emit: 'event', level: 'query' },
   *   { emit: 'event', level: 'info' },
   *   { emit: 'event', level: 'warn' }
   *   { emit: 'event', level: 'error' }
   * ]
   * 
   * / Emit as events and log to stdout
   * og: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   * 
   * ```
   * Read more in our [docs](https://pris.ly/d/logging).
   */
  log?: (LogLevel | LogDefinition)[]
  /**
   * The default values for transactionOptions
   * maxWait ?= 2000
   * timeout ?= 5000
   */
  transactionOptions?: {
    maxWait?: number
    timeout?: number
    isolationLevel?: TransactionIsolationLevel
  }
  /**
   * Global configuration for omitting model fields by default.
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   omit: {
   *     user: {
   *       password: true
   *     }
   *   }
   * })
   * ```
   */
  omit?: GlobalOmitConfig
  /**
   * SQL commenter plugins that add metadata to SQL queries as comments.
   * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   adapter,
   *   comments: [
   *     traceContext(),
   *     queryInsights(),
   *   ],
   * })
   * ```
   */
  comments?: runtime.SqlCommenterPlugin[]
}
export type GlobalOmitConfig = {
  tenant?: Prisma.TenantOmit
  organization?: Prisma.OrganizationOmit
  church?: Prisma.ChurchOmit
  campus?: Prisma.CampusOmit
  household?: Prisma.HouseholdOmit
  member?: Prisma.MemberOmit
  memberAccessRequest?: Prisma.MemberAccessRequestOmit
  staffInvite?: Prisma.StaffInviteOmit
  platformUser?: Prisma.PlatformUserOmit
  platformUserRole?: Prisma.PlatformUserRoleOmit
  subscriptionPlan?: Prisma.SubscriptionPlanOmit
  subscriptionPlanFeature?: Prisma.SubscriptionPlanFeatureOmit
  tenantSubscription?: Prisma.TenantSubscriptionOmit
  importBatch?: Prisma.ImportBatchOmit
  importBatchItem?: Prisma.ImportBatchItemOmit
  memberRegistration?: Prisma.MemberRegistrationOmit
  memberTag?: Prisma.MemberTagOmit
  memberTagAssignment?: Prisma.MemberTagAssignmentOmit
  memberMilestone?: Prisma.MemberMilestoneOmit
  group?: Prisma.GroupOmit
  onboardingWorkflow?: Prisma.OnboardingWorkflowOmit
  onboardingStep?: Prisma.OnboardingStepOmit
  memberOnboarding?: Prisma.MemberOnboardingOmit
  memberOnboardingTask?: Prisma.MemberOnboardingTaskOmit
  groupMember?: Prisma.GroupMemberOmit
  volunteerRole?: Prisma.VolunteerRoleOmit
  volunteerShift?: Prisma.VolunteerShiftOmit
  volunteerShiftAssignment?: Prisma.VolunteerShiftAssignmentOmit
  volunteerAvailability?: Prisma.VolunteerAvailabilityOmit
  survey?: Prisma.SurveyOmit
  surveyQuestion?: Prisma.SurveyQuestionOmit
  surveyResponse?: Prisma.SurveyResponseOmit
  volunteerAssignment?: Prisma.VolunteerAssignmentOmit
  event?: Prisma.EventOmit
  eventSeries?: Prisma.EventSeriesOmit
  eventRsvp?: Prisma.EventRsvpOmit
  eventBadge?: Prisma.EventBadgeOmit
  eventRegistration?: Prisma.EventRegistrationOmit
  eventAssignment?: Prisma.EventAssignmentOmit
  eventMedia?: Prisma.EventMediaOmit
  eventTicketType?: Prisma.EventTicketTypeOmit
  eventTicketOrder?: Prisma.EventTicketOrderOmit
  conversation?: Prisma.ConversationOmit
  conversationMember?: Prisma.ConversationMemberOmit
  message?: Prisma.MessageOmit
  mediaAsset?: Prisma.MediaAssetOmit
  notificationPreference?: Prisma.NotificationPreferenceOmit
  inAppNotification?: Prisma.InAppNotificationOmit
  deviceToken?: Prisma.DeviceTokenOmit
  attendance?: Prisma.AttendanceOmit
  memberRelationship?: Prisma.MemberRelationshipOmit
  donation?: Prisma.DonationOmit
  fund?: Prisma.FundOmit
  campaign?: Prisma.CampaignOmit
  paymentIntent?: Prisma.PaymentIntentOmit
  donationReceipt?: Prisma.DonationReceiptOmit
  textToGiveNumber?: Prisma.TextToGiveNumberOmit
  textToGiveMessage?: Prisma.TextToGiveMessageOmit
  payout?: Prisma.PayoutOmit
  payoutTransaction?: Prisma.PayoutTransactionOmit
  refund?: Prisma.RefundOmit
  dispute?: Prisma.DisputeOmit
  disputeEvidence?: Prisma.DisputeEvidenceOmit
  communicationSchedule?: Prisma.CommunicationScheduleOmit
  communicationDripCampaign?: Prisma.CommunicationDripCampaignOmit
  communicationDripStep?: Prisma.CommunicationDripStepOmit
  communicationDripEnrollment?: Prisma.CommunicationDripEnrollmentOmit
  communicationTemplate?: Prisma.CommunicationTemplateOmit
  communicationMessage?: Prisma.CommunicationMessageOmit
  communicationSuppression?: Prisma.CommunicationSuppressionOmit
  aiInteraction?: Prisma.AiInteractionOmit
  fundraiserPage?: Prisma.FundraiserPageOmit
  pledge?: Prisma.PledgeOmit
  recurringDonation?: Prisma.RecurringDonationOmit
  expenseCategory?: Prisma.ExpenseCategoryOmit
  expense?: Prisma.ExpenseOmit
  budget?: Prisma.BudgetOmit
  budgetItem?: Prisma.BudgetItemOmit
  auditLog?: Prisma.AuditLogOmit
  user?: Prisma.UserOmit
  staffMembership?: Prisma.StaffMembershipOmit
  facility?: Prisma.FacilityOmit
  facilityBooking?: Prisma.FacilityBookingOmit
  careRequest?: Prisma.CareRequestOmit
  careNote?: Prisma.CareNoteOmit
  sermon?: Prisma.SermonOmit
  contentResource?: Prisma.ContentResourceOmit
  tenantDomain?: Prisma.TenantDomainOmit
  tenantHealthCheck?: Prisma.TenantHealthCheckOmit
  tenantSecurityPolicy?: Prisma.TenantSecurityPolicyOmit
  supportTicket?: Prisma.SupportTicketOmit
  supportTicketMessage?: Prisma.SupportTicketMessageOmit
  webhookEvent?: Prisma.WebhookEventOmit
  liveStreamChannel?: Prisma.LiveStreamChannelOmit
  liveStreamSession?: Prisma.LiveStreamSessionOmit
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

export type GetLogType<T> = CheckIsLogLevel<
  T extends LogDefinition ? T['level'] : T
>;

export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
  ? GetLogType<T[number]>
  : never;

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */


export type PrismaAction =
  | 'findUnique'
  | 'findUniqueOrThrow'
  | 'findMany'
  | 'findFirst'
  | 'findFirstOrThrow'
  | 'create'
  | 'createMany'
  | 'createManyAndReturn'
  | 'update'
  | 'updateMany'
  | 'updateManyAndReturn'
  | 'upsert'
  | 'delete'
  | 'deleteMany'
  | 'executeRaw'
  | 'queryRaw'
  | 'aggregate'
  | 'count'
  | 'runCommandRaw'
  | 'findRaw'
  | 'groupBy'

/**
 * `PrismaClient` proxy available in interactive transactions.
 */
export type TransactionClient = Omit<DefaultPrismaClient, runtime.ITXClientDenyList>

